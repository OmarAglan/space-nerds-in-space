<!DOCTYPE html><html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<font face="Helvetica">
<title>Space Nerds In Space - A Multi-player Networked Starship Bridge Simulator</title>
<style type="text/css">
body{
        margin:40px auto;
        max-width:1200px;
        line-height:1.6;
        font-size:18px;
        color:#444;
        padding:0 10px;
}
h1,h2,h3{
        line-height:1.2;
}
pre{
        overflow:auto;
}
</style>
</head>



<h1 align=center>Hacking on Space Nerds in Space</h1>
<h2 align=center>February, 2019</h2>
<h2 align=center>Stephen M. Cameron</h2>

<p>This document is meant to be a kind of road map for the code, explaining
where various things are implemented and how the pieces fit together so that if
you want to modify the game in some way, you'll have an easier time finding your
way around the code.

<h2>Contents</h2>
<ol>
<li><a href="#purpose">Purpose</a>
<li><a href="#snisoverview">Overview</a>
<ol>
<li><a href="#whatissnis">What is Space Nerds in Space?</a>
<li><a href="#puzzle">The Big Pieces of the Puzzle</a>
<li><a href="#design">Some Design Goals</a>
</ol>
<li><a href="#snisclient">SNIS Client</a>
<ol>
<li>Overview
<li><a href="#snisclientmds">Main data structures in snis_client.c</a>
<li><a href="#snisclientiv">Important Variables in snis_client.c</a>
<li><a href="#snisclientif">Important Functions in snis_client.c</a>
<ol>
<li>go[] array
</ol>
<li><a href="#snisclientthreads">Threads</a>
<ol>
<li><a href="#snisclientlobbythread">Lobby thread</a>
<li><a href="#snisclientconnectthread">connection thread</a>
<li><a href="#snisclientreadwritethread">read and write from/to server threads</a>
<li><a href="#snisclienttexttospeechthread">text to speech thread</a>
<li><a href="#snisclientphysiothread">physical i/o thread</a>
<li><a href="#snisclientnlprocthread">natural language processing thread</a>
<li><a href="#snisclientdemoncmdthread">demon command thread</a>
<li><a href="#snisclientmainthread">Main thread</a>
<li><a href="#snisclientmainthread">Main thread</a>
<li><a href="#snisclientvoicechatdecodethread">Voice Chat Decoding thread</a>
<li><a href="#snisclientvoicechatencodethread">Voice Chat Encoding thread</a>
</ol>
<li><a href="#rendering">Rendering</a>
<ol>
<li><a href="#rendererdatastr">Some renderer data structures</a>
<li><a href="#loadingmodels">Loading models</a>
<li><a href="#usingrenderer">Using the Renderer</a>
</ol>

<li><a href="#guiwidget">GUI widget system</a>
<ol>
<li><a href="#buttons">Buttons / Checkboxes</a>
<li><a href="#textinput">Text input</a>
<li><a href="#textwindow">Text Window</a>
<li><a href="#gauges">Gauges</a>
<li><a href="#sliders">Sliders</a>
<li><a href="#pulldownmenus">Pull down menus</a>
<li><a href="#uielements">UI Elements</a>
<li><a href="#uicolors">UI Colors</a>
</ol>
<li><a href="#rolesuis">Roles and station UIs</a>
<ol>
<li><a href="#netsetup">Network Setup UI</a>
<li><a href="#navui">Navigation UI</a>
<li><a href="#weapui">Weapons UI</a>
<li><a href="#engui">Engineering UI</a>
<li><a href="#damconui">Damage Control UI</a>
<li><a href="#sciui">Science UI</a>
<li><a href="#commsui">Comms UI</a>
<li><a href="#demonui">Demon UI</a>
<li><a href="#lobbyui">Lobby UI</a>
</ol>
<li><a href="#kmjinput">Keyboard, Mouse and Joystick Input</a>
<li><a href="#audio">Audio</a>
<li><a href="#speechrecog">The Computer / Speech Recognition</a>
<li><a href="#starmap">Star Map / Warp gate traversal</a>
<li><a href="#voicechat">Voice Chat</a>
</ol>
<li><a href="#snisserver">SNIS Server</a>
<ol>
<li><a href="#snisserveroverview">Overview</a>
<li><a href="#snisserverdatastr">Main data structures</a>
<ol>
<li><a href="#snisserverclientarr">client[] array</a>
<li><a href="#snisserverbridgelist">bridgelist[] array</a>
<li><a href="#snisservergo">go[] array</a>
</ol>
<li><a href="#snisserverthreads">Threads</a>
<ol>
<li><a href="#snisserverlistenerthr">Listener thread</a>
<li><a href="#sniserverreadwritethr">Client reader and writer threads</a>
<li><a href="#snisservermvreadwritethr">Multiverse reader and writer threads</a>
<li><a href="#snisserverssglthr">SSGL thread</a>
<li><a href="#snisserversrvrtrkr">Server Tracker thread</a>
<li><a href="#snisservermainthr">Main thread</a>
</ol>
<li><a href="#snisserverplayership">Player ship systems</a>
<ol>
<li><a href="#snisserverpwrcool">Power and coolant models</a>
<li><a href="#snisservercollision">Collision detection</a>
<li><a href="#snisserverplayershipmove">Player Ship movement</a>
</ol>
<li><a href="#snisservernpcship">NPC Ships</a>
<ol>
<li><a href="#snisservernpcmove">Movement</a>
<li><a href="#npcdebugging">Debugging NPC ship AI</a>
<li><a href="#snisservernpcai">NPC ship AI</a>
<li><a href="#snisservernpcfleet">NPC Fleets</a>
<li><a href="#snisserverhostile">Hostility matrix</a>
</ol>
<li><a href="#snisservertweak">Tweakable variables</a>
<li><a href="#snsiservernpccomms">NPC Comms (starbases, mining bot, etc)</a>
<li><a href="#snisservernlproc">Natural Language Processing</a>
<li><a href="#snisserverrtsmode">RTS mode</a>
<li><a href="#snisserverdamconai">Damage Control Robot AI</a>
</ol>
<li><a href="#snismultiverse">SNIS Mulitverse</a>
<ol>
<li><a href="#mvdatastr">Main data structures</a>
<li><a href="#snismultiversethreads">Threads</a>
<ol>
<li><a href="#mvlistenerthr">Listener thread</a>
<li><a href="#mvreadwritethr">SNIS Server Reader / Writer threads</a>
<li><a href="#mvssglthr">SSGL thread</a>
<li><a href="#mvmainthr">Main thread</a>
<li><a href="#mvdataxfer">Data transfer between snis_multiverse and snis_server</a>
</ol>
</ol>
<li><a href="#ssglserver">SSGL Server</a>
<ol>
<li><a href="#ssgloverview">SSGL Overview</a>
<li><a href="#ssgldatastruct">SSGL Main data structures</a>
<li><a href="#ssglserverthr">SSGL Server threads</a>
</ol>
<li><a href="#buildsystem">Build System</a>
<ol>
<li><a href="#dependencies">Prerequisites (dependencies)</a>
</ol>
<li><a href="#utilities">Utilities</a>
<ol>
</ol>
<li><a href="#assets">Assets</a>
<li><a href="#fileindex">Source File Index</a>
<ol>
</ol>
</ol>

<h2><a name="purpose">Purpose</a></h2>
<p>This is a guide to hacking on the code base for <a href="https://spacenerdsinspace.com">Space Nerds In Space</a>.
It is intended to help you understand the basics of how the game works, what the various pieces are, how they fit
together, and where to find the code corresponding with a given bit of functionality. It is not the authoritative
description of how things works (that would be the code) nor will it explain every little detail.
It is just a guideline to help you try to figure out how things work, how they fit together and to help
you navigate your way around the code base.

<h2><a name="snisoverview">Overview</a></h2>

<h3><a name="whatissnis">What is Space Nerds in Space?</a></h3>

<p>Space Nerds in Space is a multi-player networked starship bridge simulator. You and your friends
gather in a room with a bunch of computers, a projector and a stereo system.  One or more computers
act as a server simulating a star system and the spaceships, planets, asteroids and so on within it,
and some of the computers act as the stations or terminals on your simulated starship.  There are
stations for Navigation, Weapons, Engineering, Damage Control, Science, Communications, the Main View
(showing an out-the-window view into space) and finally the Demon screen (or gamemaster screen).

<h3><a name="puzzle">The Big Pieces of the Puzzle</a></h3>

<p>There are four main software executables that make up a running Space Nerds in Space system.
<ul>
<li>ssgl_server - the lobby server for the system. Only one instance of ssgl_server runs.
<li>snis_server - simulates a starsystem. There may be several snis_server instances running.
<li>snis_multiverse - facilitates player travel between snis_server instances and starts and stops snis_server instances
<li>snis_client - This is the UI of the system. There is one instance of snis_client per station on each bridge in the system.
</ul>

<p align=center><img src="multiplayer-setup.png">
<p align=center>Hardware and software setup for Space Nerds in Space

<h3><a name="design">Some Design Goals</a></h3>

<p>Space Nerds in Space has been a slowly evolving project since roughly November of 2012. Not everything
it has become since then was imagined at that time. For example, the game was originally imagined as a primarily 2D
game without any OpenGL at all, and traveling from one snis_server instance to another was not part of the
original design (and it shows). That being said, most of the original design (which formed and existed mainly in my
head) remains intact, and has held up pretty well.

<p>Some of the main ideas that drove the design and which still hold:

<ol>
<li>snis_server should be "headless" and have no UI whatsoever.
<li>snis_server should support multiple bridges
<li>snis_server is authoritative (all meaningful state is within snis_server instances, none within snis_client)
<li>clients should be able to attach to and detach from a bridge at will with no disruption. It should be possible
to join or leave game at any time with no disruption to other players.
<li>If there is more than one instance of a particular station on a bridge, then all
instances of that station on that bridge should effectively show exactly the same thing. (Excluding very minor differences,
e.g. the flickering noise of engineering power levels is not identical from one station to another, but all <em>consequential</em>
data should be identical. There is
<a href="https://github.com/smcameron/space-nerds-in-space/commit/7373459e4cb64944b90eacf1c864647bec60ebd2">one
other significant exception</a>.)
<li>The "main screen" should be able to mirror the display of any client on the same bridge so
the captain can give Picard's typical order: "On screen!" (This is accomplished via the previous item).
<li>Network traffic between processes takes the form of single byte "opcodes" each followed by its own
particular operands of varying sizes.  The protocol should be endian-clean.
<li>There should be a lobby server to enable the various processes to find one another on the network.
<li>The bulk of the code should be in C. No C++. The reason for this is because I find programming
C to be fun, but find programming in C++ to be the opposite of fun.  SNIS development is optimized
for Steve's fun.
</ol>


<h4>ssgl_server</h4>

<p>ssgl_server is the lobby server for the game.  It is how the various pieces of the game find
each other on the network. Each snis_server process registers itself with the ssgl_server informing
it of the snis_server's IP address and port number. Likewise the snis_multiverse_process registers
itself with the lobby server with its IP address and port number. The snis_server instances consult
the lobby server to find the IP address and port of the snis_multiverse server with which they then
communicate directly. The snis_client processes consult with the lobby server to find the IP address
and port of the snis_server instances, with which they may then communicate directly.

<h4>snis_server</h4>

<p>The snis_server processes each run a simulation of a single star system and all the planets, asteroids, NPC ships,
black holes, star bases, and player ships (aka bridges), and so on within that star system. snis_client instances connect
to a snis_server process and join (or create) a bridge within that system.  All the snis_clients for the stations of any
one particular bridge connect to the same snis_server process, and multiple bridges may exist within a snis_server process.
The snis_server simulation runs at a rate of 10Hz. That is, ten times a second, the snis_server process updates the positions
and orientations of all objects that it is simulating (NPC ships, planets, asteroids, player ships, etc.) With each tick it
also transmits this information to every connected client (more or less, I'm ignoring some details for now). The snis_client
processes transmit requests to the snis_server for every player action.  For instance, if the navigator wishes to increase
the impulse power to speed the ship up, this would occur as a request from the navigator's snis_client instance to the
snis_server, which would adjust the simulation, and then the results of that adjustment naturally get transmitted back to
the all the relevant snis_client instances. All the communcations between snis_client and snis_server take the form of
"op codes" (a single byte) followed by the operands for that particular opcode (which may be many bytes).
See <a href="snis-protocol.html">snis-protocol.html</a> for a detailed description of the opcodes.

<h4>snis_multiverse</h4>

<p>snis_multiverse exists to allow player ships to traverse between snis_server instances. The state of the player's
ship is maintained moment-to-moment within the memory of a snis_server process. The state of the player's ship includes
everything about the ship: how much fuel it has, all the power and coolant settings in engineering, how much money
the player has, and many many other things. If we want a player's ship to travel
from one snis_server instance to another (from one star system to another) we have to capture all this state and transfer
it from one snis_server instance to another.  This is what snis_multiverse allows.  Periodically, each snis_server transmits
the state of each bridge it is currently simulating to snis_multiverse.  This state is then stored by snis_multiverse in a file.
When a snis_client connects to a snis_server process and joins a bridge that wasn't previously present in this snis_server,
snis_server can obtain the current state of this bridge from snis_multiverse. In this way, a new player ship appearing within
snis_server can be made to have the same state as a ship which just left a different snis_server instance, giving the illusion
that the ship has travelled from one instance to another.

<h4>snis_client</h4>

<p>snis_client is the user interface with which players interact. It presents all the screens, navigation, weapons, engineering,
damage control, science, communications, main view, and the demon screen. Additionally it plays sounds and speech. All player
input occurs within snis_client, and these inputs are translated to opcode requests that are sent to the connected snis_server
instance. The snis_server instance is almost continually spraying opcodes to the snis_client to update it with the latest
position, orientation, presence or absence and other attributes of various objects within the simulated star system. On starting
up, after configuring a few options (i.e. which roles this particular snis_client instance will play) snis_client first
connects to the ssgl_server and obtains a list of snis_server instances which is presented to the
user. The user can then select a snis_server instance to which snis_client then connects.

<h2><a name="snisclient">SNIS Client</a></h2>
<h3>Overview</h3>
<p>
<h3><a name="snisclientmds">Main Data Structures in snis_client.c</a></h3>
<h4><a name="goarray">struct snis_entity go[] array</a></h4>
<p>Both snis_client and snis_server contain a statically allocated global array of struct snis_entity.
snis_entity is defined in <b>snis.h</b> (search for "<b>struct snis_entity {</b>"). The array is named "go"
as short for "game object". Objects are internally allocated from this array using a snis_object_pool
(see <b>snis_alloc.h</b> and <b>snis_alloc.c</b>) which maintains a large bit string to track which elements of the
go[] array are in use and which are free. Elements of go[] are "allocated" in snis_client via snis_object_pool_alloc_obj()
and freed via snis_object_pool_free(). This is done in snis_client.c mainly in in add_generic_object()
(search for "<b>^static int add_generic_object</b>") though in a few other places too.

<p>The go[] array needs to be protected by locking the universe_mutex within snis_client and snis_server.

<p>Note that the client has some other arrays of snis_entity besides go[]. There is one for "sparks"
which has no corresponding array within snis_server, and there is one for damage control objects
called dco[] (all the things on the damage control screen like the robot, and the various modules).

<p>Each element of go[] is a snis_entity.  Each snis_entity has quite a few fields.  Note that some fields
exist only on in snis_server, and some fields exist only on snis_client.

<pre>
struct snis_entity {
        uint32_t id;
        double x, y, z;
        double vx, vy, vz;
        double heading;
        uint16_t alive;
        uint32_t type;
        uint32_t timestamp;
        uint32_t respawn_time;
        union type_specific_data tsd;
        move_function move;
        struct snis_entity_science_data sdata;
        union quat orientation;
#ifdef SNIS_SERVER_DATA
        struct space_partition_entry partition;
#endif
#ifdef SNIS_CLIENT_DATA
        struct entity *entity;
        int nupdates;
        double updatetime[SNIS_ENTITY_NUPDATE_HISTORY];
        union vec3 r[SNIS_ENTITY_NUPDATE_HISTORY];
        union quat o[SNIS_ENTITY_NUPDATE_HISTORY];
        struct snis_entity *shading_planet;
#endif
        char ai[6];
};
</pre>

<p>The id field is a unique ID generated by snis_server and transmitted to the client when the server instructs the client to create the object.
It is how the client and server know which object the other process is refering to in any opcodes operating on an object.

<p><b>x, y, z</b> and <b>vx, vy, vz</b> are the position and velocity of the object in space.
<p><b>alive</b>: when "alive" is nonzero, the object is active, and when 0, the object is inactive.
On the client this controls the lifetime of e.g. sparks (which are not represented by the go[] array,
but by the spark[] array.)
<p><b>type</b> defines what kind of object this is (e.g. OBJTYPE_ASTEROID, OBJTYPE_SHIP, OBJTYPE_PLANET, OBJTYPE_STARBASE, etc. see snis.h)
<p><b>timestamp</b> is used by snis_server to know when the last time this object changed was and if its new status needs to be sent to clients.
On the client it is not generally used (I think?) but updatetime[] is used in interpolating between positions and orientations during times
between the server's 10Hz updates.
<p><b>respawn_time</b>: used to know when to respawn a player's ship (this should not really be in *every* snis_entity.)
<p><b>tsd</b> This is "type specific data", and what's in it depends on the <b>type</b> field.
<p><b>move</b> is a pointer to the object's move function. This is generally the same for all objects of any given type.
<p><b>sdata</b> sdata is short for "science data". The idea being that data in here is considered to have been obtained by
the science scanner beam (even though it really isn't) and should be "forgotten" after awhile on the client.
<p><b>orientation</b> a quaternion for the object's orientation in space.
<p><b>updatetime[], r[], o[]</b> these are parallel arrays of update time, orientation and position that form the recent history of the object
as updated by the server. These are used to interpolate the object's position and orientation at a rate faster than the server's update rate
(30Hz vs 10Hz). See interpolate_generic_object() and interpolate_oriented_object() in snis_client.c
<p><b>ai[]</b>: This is a hack to allow the client to have some insight into NPC AI state for debugging, with a single character
for each AI state, and an array of 6 to allow it to know the state in each frame of the NPC AI stack.
<p><b>shading_planet</b> - If NULL, then the object is not within the shadow of a planet. If not null then it is a pointer to
the planet's snis_entity; This is used only by snis_client to determine whether to shine sunlight on an object or not when
rendering.

<h3><a name="snisclientiv">Important Variables in snis_client.c</a></h3>

<h4>displaymode</h4>
<p>static volatile int displaymode = DISPLAYMODE_LOBBYSCREEN;

<p>The displaymode variable controls which screen is rendered for the current frame within snis_client.c
and is an important state variable used in connecting to ssgl_server and snis_server.

<p>Consult snis_packet.h and search for 'define DISPLAYMODE_' to see the possible values for displaymode.

<h4>to_server_queue</h4>

<pre>
	static struct packed_buffer_queue to_server_queue;
</pre>

<p>to_server_queue is a queue of packed_buffers that will be transmitted to snis_server by
the gameserver_writer() thread.  It must be protected by the to_server_queue_mutex.  There is
also a to_server_queue_event_mutex which is used along with server_write_cond to control
the gameserver_writer_thread() -- wake it up or kill it as needed.  All opcodes and operands
from snis_client to snis_server pass through this queue.

<h4>uiobjs</h4>

<pre>
	static struct ui_element_list *uiobjs = NULL;
</pre>

<p>uiobjs is a list of UI elements that is dynamically constructed. It ultimately contains a list
of all UI widgets in the game, tagged with the displaymode for which they are active. See snis_ui_element.h

<h4>pool, damcon_pool</h4>

<pre>
static struct snis_object_pool *pool;
static struct snis_object_pool *damcon_pool;
</pre>

These are bit arrays used to track the free or in-use status of go[] and dco[] elements. See snis_alloc.h

<h4>damcon_ui, nav_ui, demon_ui, lobby_ui, sci_ui, comms_ui, net_setup_ui, eng_ui</h4>

Structures containing the UI widgets and data for the various screens; See the following functions
in snis_client.c:

<pre>
        init_lobby_ui();
        init_nav_ui();
        init_engineering_ui();
        init_damcon_ui();
        init_weapons_ui();
        init_science_ui();
        init_comms_ui();
        init_demon_ui();
        init_net_setup_ui();
</pre>



<h4>

<h4>

<h3><a name="snisclientif">Important Functions in snis_client.c</a></h3>

<h4>process_events()</h4>

<p>process_events() is called from the main loop in main() at a rate of 60 Hz to process SDL events.
Mouse movement, mouse wheel and button presses, key up, key-down, quit, and window resize events are
handled here.

<h4>main_da_expose()</h4>

<p>main_da_expose() is called from the main loop at the bottom of main(),
(main_da_expose means main drawing area expose) at 60 or 30Hz (depending on user
tweakable variable use_60_fps.)
This function is what draws the main drawing area -- which covers the entire screen.  In other words, it is what draws
<em>everything that appears on the screen</em>.

<p>Within main_da_expose, there is a big switch statement which draws the appropriate screen
depending on the value of displaymode.  See also the following functions in snis_client.c
responsible for drawing the various screens:

<pre>
	show_lobbyscreen();
	show_mainscreen();
	show_navigation();
	show_manual_weapons();
	show_engineering();
	show_3d_science(); /* the long range scanner screen */
	show_science(); /* short range scanners (SRS) */
	draw_sciplane_display(); /* main radar display on SRS */
	draw_science_data(); /* data on right hand side of science screens */
	draw_science_waypoints(); /* science waypoints screen */
	show_comms();
	show_demon();
	show_damcon();
	show_network_setup();
</pre>

<p>main_da_expose() also calls the following which draw all the UI widgets for the current
displaymode.

<pre>
	ui_element_list_draw(uiobjs);
	ui_element_list_maybe_draw_tooltips(uiobjs, mouse.x, mouse.y)
</pre>

<h4>advance_game()</h4>

advance_game() is called at a rate of 60Hz from the main loop:

<p>advance_game() moves objects and sparks on the client (doing interpolation between server updates),
expires starmap entries (how stars get removed from the starmap when snis_server processes exit) and notifies
the server if the user has requested a change to the current displaymode (switched the screen
to a different role, e.g. from Navigation to Weapons). (Ordinarily the server doesn't care which displaymode
a client is currently on, but this is used for allowing the server to "lock" clients to their current role
via the demon screen.)

<p>advance_game() is also is involved in switching the client to connect to a different snis_server when
a warp gate is traversed, triggered by receipt of OPCODE_SWITCH_SERVER from the currently
connected snis_server instance. This snis_server switching business is one of the more complicated
parts and could probably be simplified, somehow.

<p>advance_game() also polls the state of joysticks and processes changes in state of the keyboard
and mouse (previously recorded by process_events()), and with any custom physical io devices
(deal_with_physical_io_devices() -- of which there are currently none).

<h4>Keyboard callbacks: key_press_cb, key_release_cb</h4>

<p>Called by process_events() when a key press or release event occurs. Keyboard handling stuff is here. See also
deal_with_keyboard() in snis_client.c which acts on information collected in the aforementioned
event handling functions.

<h4>Mouse button callbacks: main_da_button_press, main_da_button_release, main_da_motion_notify</h4>

<p>Called by process_events() when there are mouse button press, release or motion events. See also deal_with_mouse()
in snis_client.c which also acts on information collected in the aforementioned event handler functions.

<h3><a name="snisclientthreads">snis_client Threads</a></h3>

<h4><a name="snisclientlobbythread">snis_client lobby threads</a></h4>

<h5>Main lobby thread</h5>

<p>See connect_to_lobby_thread() in snis_client.c

<p>The purpose of this thread is to connect to ssgl_server and receive periodic updates to the list
of running snis_server instances. This thread runs indefinitely.

<p>The snis_client lobby thread is created when the player clicks the CONNECT TO LOBBY button
on the network setup screen, or when the player clicks on the IP address of a detected lobby
server on the pull down menu of the network setup screen. (see connect_to_lobby_button_pressed()
in snis_client.c)  This action triggers a call to connect_to_lobby(), which creates the lobby
thread running the function connect_to_lobby_thread() in snis_client.c.

<p>This thread connects to ssgl_server via ssgl_gameclient_connect_to_lobby() (see ssgl/ssgl.h
and ssgl/ssgl_connect_to_lobby.c) and then enters a loop.  In the loop, it
receives a list of game servers via ssgl_recv_game_servers() (see ssgl/ssgl.h) which
it then copies to the lobby_game_server[] array under protection of a mutex, and then
sleeps for a bit. It exits the loop upon an error or if the program exits.

<p>The lobby_game_server[] array is used by show_lobbyscreen() in another thread to display the list of
snis_server instances to the user.

<h5>Lobby broadcast packet receiving thread</h5>

<p>So that the players do not need to know the IP address of the lobby server,
the lobby server broadcasts UDP packets advertising its existence and port. Clients
of ssgl_server (e.g. snis_client) may register to receive these packets by calling
ssgl_register_for_bcast_packets() (see ssgl/ssgl_register_for_bcast_packet.c). This creates
two threads, one to receive these broadcast packets, and one to expire old lobby
information (see below). Each incoming packet contains an IP address, a port, and
a hostname. These are saved in an lobbylist[] (see ssgl_register_for_bcast_packet.c).

<h5>Lobby expiring thread</h5>

ssgl_register_for_bcast() creates a thread to notice when the internal list of lobby servers
(lobbylist[]) has changed and for calling a notification function, passing this new information
when such changes are detected.  Whenever the lobbylist[] array changes, the callback function
provided to ssgl_register_for_bcast_packets is called, and this new lobby data is passed.

<p>For snis_client, this notification function is lobby_list_change_notification() in
snis_client.c. It uses the information passed in to construct pull down menu entries
for the network setup screen.  In this way, when on the network setup screen, hovering
the mouse in the upper left hand corner of the screen brings down a menu containing all
the lobby servers discovered via these broadcast packets.

<h4><a name="snisclientconnectthread">The snis_client connection thread</a></h4>

<p>This thread is created when the user presses the CONNECT TO SERVER button next to one of the
snis_server instances displayed on the lobby screen (see lobby_connect_to_server_button_pressed()
in snis_client.c)

<p>The thread is created by connect_to_gameserver(), and the thread function is connect_to_gameserver_thread().

<p>This thread connects to the selected snis_server instance, writes the SNIS_PROTOCOL_VERSION to this socket,
then sends an OPCODE_UPDATE_PLAYER with some parameters to indicate whether this is a request to create a new
player ship or to join an existing ship, the requested client roles, the ship name and ship password and which
warp gate number if traversing from one snis_server to another (or 0xff when first joining the game when there
is no warp gate).

<p>This thread then creates two more threads, a reader and a writer thread for communicating with the
connected snis_server instance.

<p>Then it sends a list of the opcodes this client knows about and their formats (the server will cross
check these against its own in order to detect incompatibilites as soon as possible, and may send back
an opcode indicating any such incompatibilites.)

<p>Then requests a universe timestamp from the server, and sends build information to the server
(see build_info.h -- which is machine generated).

<p>This thread then exits.

<h4><a name="snisclientreadwritethread">Read and Write from/to snis_server threads</a></h4>

<p>See gameserver_reader() in snis_client.c and gameserver_writer() in snis_client.c

<p>The gameserver_reader() thread in snis_client.c enters an indefinite while loop in
which it receives an opcode from snis_server and then there's a big switch statement
to process the opcode which involves reading the opcode's operands and then doing
whatever the opcode indicates.  Usually this is updating the state of some object
in some way. <em>This is the path by which all information from snis_server to
snis_client travels</em>.

<p>The gameserver_writer() thread in snis_client.c also enters an indefinite while
loop in which it waits for serverbound packets to appear in a queue
(to_server_queue) that it is monitoring,  and then writes any packets it finds
in the queue to the server. This thread will exit if the player traverses a
warp gate (because that means switching to a new snis_server, so when that
happens, a new gameserver_writer() thread will be created, and this one,
connected to the old snis_server is no longer needed.)

<p>New packets are placed into the to_server_queue whenever the client needs to inform
the server of something -- whenver the client needs to send an opcode to the server
it does so by constructing the opcode packet and putting it in the to_server_queue
and lets the gameserver_writer() thread to the actual sending of the packet. You will
see many functions named send_blah_blah() which call
packed_buffer_queue_add(&amp;to_server_queue, ...) -- that is how packets are added
to the queue.

<h4><a name="snisclienttexttospeechthread">Text to speech thread</a></h4>

<p>This thread supports text-to-speech requests from snis_server to snis_client.

<p>This thread is started via setup_text_to_speech_thread() called from main() in snis_client.c The main
thread function is text_to_speech_thread_fn(), which waits for input to appear on a queue
(text_to_speech_queue_head) and when some text appears, it pulls it off the queue and calls do_text_to_speech()
which suppresses duplicate entries before running bin/snis_text_to_speech.sh, passing it the text to
say.  The queue that text_to_speech_thread_fn() monitors is fed by text_to_speech() in snis_client.c
which is called by process_natural_language_request() in snis_client.c, which is triggered by an opcode
from the server, via gameserver_reader() in snis_client.c

<h4><a name="snisclientphysiothread">Physical i/o thread</a></h4>

<p>This thread is intended to support physical i/o to home-made controls. The idea is it monitors
a socket for data (see snis-device-io.c and snis-device-io.h) and then transforms this data into
inputs into the game. One additional note: in this case, the socket is an AF_UNIX socket (so not
a network socket) and it is using a special linux abstract socket address, see "The Linux
Programming Interface", by Michael Kerrisk, Ch. 57, p. 1175-1176, and also see the output of
"man 7 unix", under address type "abstract".

<p>The main thread function for this thread is in snis_client.c, monitor_physical_io_devices(), which
collects data from the socket and calls process_physical_device_io() which contains a big switch
statement to perform all the requested actions.

<p>Note snis-device-io.c is not part of snis_client. It is a library intended for use by programs
that read directly from physical i/o devices (e.g. a USB serial port connected to e.g. a Raspberry
Pi or Arduino or the like which has a bunch of buttons and toggle switches and whatnot). This
hypothetical program would monitor the state of the toggle buttons and switches and whatever
and then use the functions provided by snis-device-io.c to convey commands to snis_client via
the socket.

<p>See device-io-sample-1.c for a very simple example of such a hypothetical program. This
program just reads opcodes from the keyboard, but in theory it could be modified to read
a serial port connected to a home-made set of controls instead.


<h4><a name="snisclientnlprocthread">Natural language processing thread</a></h4>

<p>This thread is responsible for monitoring the fifo /tmp/snis-natural-language-fifo for
natural language text commands, and forwarding such commands to snis_server.

<p>This thread is started by setup_natural_language_fifo(), called from main() in snis_client.c.
It monitors a fifo (see mkfifo(3)), /tmp/snis-natural-language-fifo for natural language requests.
The main thread function is monitor_input_fifo(). This thread has some per-thread data passed in
arg, which contains a struct input_fifo_thread_data, which contains a function pointer (process_input)
used to process data from the fifo.  In the case of this thread, that process_input points to
send_natural_language_request_to_server(), which sends the commands to snis_server to be acted upon.

<h4><a name="snisclientdemoncmdthread">Demon command thread</a></h4>

<p>This thread is responsible for monitoring the fifo /tmp/snis-demon-fifo for
demon screen text commands, and forwarding such commands to snis_server.

<p>This thread is started by setup_demon_fifo(), called from main() in snis_client.c.
It monitors a fifo (see mkfifo(3)), /tmp/snis-demon-fifo for demon text requests.
The main thread function is monitor_input_fifo(). This thread has some per-thread data passed in
arg, which contains a struct input_fifo_thread_data, which contains a function pointer (process_input)
used to process data from the fifo.  In the case of this thread, that process_input points to
send_demon_text_command(), which sends the commands to snis_server to be acted upon.

<p>This can be used in conjunction with other software to for example
<a href="https://github.com/smcameron/space-nerds-in-space/issues/193">allow demon commands to be triggered via a smartphone</a>.

<h4><a name="snisclientmainthread">Main thread</a></h4>

<p>See main() in snis_client.c, at the end of the file.

<p>There is a lot of initialization, reading of config files, parsing of options, setting up SDL windows, etc.
at the beginning which I won't describe here.

Towards the bottom of main() is a <em>while</em> loop. This is the main loop of the game
and it runs at a rate of 60 Hz. It calls process_events() and advance_game() at
60Hz, and main_da_expose() to draw the screen at 30 or 60 Hz depending on the user
tweakable variable use_60_fps. The default is 30 Hz.

<h4><a name="snisclientvoicechatdecodethread">Voice Chat decoding thread</a></h4>

<p>See voice_chat_decode_thread_fn() in snis_voice_chat.c.  This thread pulls
Opus encoded audio packets off a queue, decodes them, and  appends them to a
chain of audio that the mixing code plays back.  See the section below about
<a href="#voicechat">voice chat</a>.

<h4><a name="snisclientvoicechatencodethread">Voice Chat encoding thread</a></h4>

<p>See voice_chat_encode_thread_fn() in snis_voice_chat.c.  This thread pulls
fixed size PCM audio data off a queue, encodes via libopus, and transmits them
to snis_server to be forwarded to other clients. See the section below about
<a href="#voicechat">voice chat</a>.

<h4><a name="snisclientpngdecodethread">PNG decoding threads</a></h4>

<p>There is a generic work queue system in workqueue.h and workqueue.c.
At the moment this work queue system is only used for decoding PNGs. There
two work queues, one for decoding PNG files, which has 4 associated threads
for decoding PNG files, and one for uploading decoded image data to the GPU.
This 2nd work queue does not have any generic threads associated with it, instead
the main rendering threads consumes items from this queue because only the main
rendering thread has the OpenGL context to be able to do so.  The work queues
are created in graph_dev_init(), and the various functions in graph_dev_opengl.c
that load textures put work items into the png decoding queue.

<h3><a name="rendering">Rendering</a></h3>

<p>entity.h and graph_dev.h define the interface to the renderer, with entity.h
defining the higher level and common parts while graph_dev.h defines parts that have
renderer specific parts.

<p>graph_dev_gdk.c and graph_dev_opengl.c are the two specific implementations of this interface
that graph_dev.h defines, and entity.c implements the device independent part of the renderer
defined by entity.h.

<p>Describing all the gory details of the renderer is more than I'm able to do here.

<p>GLSL shaders are in share/snis/shader:

<p align=center><table align=center, width=80%, border=1>
<tr><td>alpha_by_normal.shader</td><td>Used by Demon screen</td></tr>
<tr><td>atmosphere.frag</td><td>Renders planetary atmospheres</td></tr>
<tr><td>atmosphere.vert</td><td>Renders planetary atmospheres</td></tr>
<tr><td>color_by_w.frag</td><td>Used by the "trident" on the Nav screen</td></tr>
<tr><td>color_by_w.vert</td><td>Used by the "trident" on the Nav screen</td></tr>
<tr><td>fs-effect-copy.shader</td><td>For copying frame buffers (used by anti-aliasing)</td></tr>
<tr><td>line-single-color.frag</td><td>shader for drawing lines</td></tr>
<tr><td>line-single-color.vert</td><td>shader for drawing lines</td></tr>
<tr><td>per_vertex_color.frag</td><td>Used for lots of 2D drawing (UI stuff)</td></tr>
<tr><td>per_vertex_color.vert</td><td>Used for lots of 2D drawing (UI stuff)</td></tr>
<tr><td>point_cloud.frag</td><td>Used for dotted lines on science LRS, SRS</td></tr>
<tr><td>point_cloud.vert</td><td>Used for dotted lines on science LRS, SRS</td></tr>
<tr><td>single_color.frag</td><td>Used for drawing lines for some debugging things (Normal lines)</td></tr>
<tr><td>single_color.vert</td><td>Used for drawing lines for some debugging things (Normal lines)</td></tr>
<tr><td>single-color-lit-per-pixel.frag</td><td>Not used</td></tr>
<tr><td>single-color-lit-per-pixel.vert</td><td>Not used</td></tr>
<tr><td>single-color-lit-per-vertex.frag</td><td>Used for untextured models</td></tr>
<tr><td>single-color-lit-per-vertex.vert</td><td>Used for untextured models</td></tr>
<tr><td>skybox.frag</td><td>Renders skybox</td></tr>
<tr><td>skybox.vert</td><td>Renders skybox</td></tr>
<tr><td>smaa-blend.shader</td><td>subpixel morphological anti-aliasing</td></tr>
<tr><td>smaa-edge.shader</td><td>subpixel morphological anti-aliasing</td></tr>
<tr><td>smaa-high.shader</td><td>subpixel morphological anti-aliasing</td></tr>
<tr><td>SMAA.hlsl</td><td>subpixel morphological anti-aliasing</td></tr>
<tr><td>smaa-neighborhood.shader</td><td>subpixel morphological anti-aliasing</td></tr>
<tr><td>textured-and-lit-per-pixel.shader</td><td>Used for textured models with specular and optional emit and normal textures</td></tr>
<tr><td>textured-and-lit-per-vertex.shader</td><td>Not used</td></tr>
<tr><td>textured-cubemap-and-lit-per-pixel.shader</td><td>Used for rendering planets with and without normal maps</td></tr>
<tr><td>textured-cubemap-and-lit-per-vertex.shader</td><td>Not used</td></tr>
<tr><td>textured-cubemap-and-lit-with-annulus-shadow-per-pixel.shader</td><td>Used for rendering planets with ring shadows and with or without normal maps</td></tr>
<tr><td>textured-cubemap-shield-per-pixel.shader</td><td>Renders shield effect</td></tr>
<tr><td>textured-particle.frag</td><td>Renders particle effects (e.g. thrust plumes)</td></tr>
<tr><td>textured-particle.vert</td><td>Renders particle effects (e.g. thrust plumes)</td></tr>
<tr><td>textured.shader</td><td>Used for unlit textured models, e.g. Nebula</td></tr>
<tr><td>textured-with-sphere-shadow-per-pixel.shader</td><td>Used to render planet rings</td></tr>
<tr><td>wireframe_filled.frag</td><td>Used on e.g. Science details screen to render models, and when renderer in wireframe mode (ctrl-R)</td></tr>
<tr><td>wireframe_filled.vert</td><td>Used on e.g. Science details screen to render models, and when renderer in wireframe mode (ctrl-R)</td></tr>
<tr><td>wireframe_transparent.frag</td><td>Used when renderer in wireframe mode (press ctrl-R a few times)</td></tr>
<tr><td>wireframe_transparent.vert</td><td>Used when renderer in wireframe mode (press ctrl-R a few times)</td></tr>
<tr><td>wireframe-transparent-sphere-clip.frag</td><td>Used on Nav screen to render models.</td></tr>
<tr><td>wireframe-transparent-sphere-clip.vert</td><td>Used on Nav screen to render models.</td></tr>
</table>

<p>If you're new to rendering, take a look at this link:
<a href="http://www.kmjn.org/notes/3d_rendering_intro.html">http://www.kmjn.org/notes/3d_rendering_intro.html</a>

<h4><a name="rendererdatastr">Some renderer data structures</a></h4>

<ul>
<li>struct vertex : vertex.h - defines a vertex in a mesh.
<li>struct triangle : triangle.h - Defines a triangle in a mesh
<li>struct mesh : mesh.h - A set of triangles making up a mesh
<li>struct material : material.h -Contains data necessary for various shaders (e.g. textures, colors, lighting information, etc.)
<li>struct entity : entity_private.h - Contains data for models displayed in the game, meshes, materials, coordinates, orientations, etc.
<li>struct entity_context : entity_private.h - Contains sets of entities for
various 3D renderings in the game, camera settings, etc.  E.g. there's an
entity context for the main screen, a entity context for the instruments (e.g.
science, navigation, demon screen).  For the main screen context, entities are persistent (last
more than one frame) and items in the go[] array have associated entities in this context.
Other contexts have transient entities (added and removed each frame). This is mainly because
the main screen was done first before there was a recognized need for multiple entity contexts.
Here are the entity contexts in snis_client.c:
<ul>
<li>static struct entity_context *ecx; /* main entity context for main screen and weapons */
<li>static struct entity_context *sciecx; /* Used by SRS on science */
<li>static struct entity_context *instrumentecx; /* Used by nav screen, sciplane screen, and demon screen */
<li>static struct entity_context *tridentecx; /* Used for the miniature wombat attitude indicator on Nav */
<li>static struct entity_context *sciballecx; /* used for the LRS "sci-ball" on science */
<li>static struct entity_context *network_setup_ecx; /* used for the rotating wombat */
</ul>
</ul>

<p>struct mesh is the main data structure used to represent models in the game. Meshes can be
created via specialized functions (e.g. for spheres for planets), by reading in data via
read_mesh() in stl_parser.[ch] (read_mesh() can read stl files, wavefront obj files, and
oolite's dat files)

<p>struct entity associates meshes with materials and contains the world and camera coordinate
positions of the mesh and the orientation of the mesh.  Materials are how the renderer knows
what shader to use for a given mesh.

<p>Shaders are read and compiled by functions in graph_dev_opengl.c, see graph_dev_setup().

<h4><a name="loadingmodels">Loading models</a></h4>

<p>Models are loaded with read_mesh() in mesh.c, called from snis_read_model() in snis_client.c.
snis_read_model() is called many times from init_meshes() to read all the meshes for the game.
Note that init_meshes() is called from main_da_configure(), which is a bit strange. This was because
when reading the meshes, it was performing some OpenGL calls to map textures, etc. and all
these OpenGL calls must be done from the thread with the opengl context.

<p>As of June 2025, the PNG decoding duties have been split apart from the main rendering
thread.  Instead, the main rendering thread requests PNG files to be loaded by putting
requests on a work queue serviced by worker threads.  Those worker threads decode the PNG
files and pass the requests to a completion queue.  The main rendering thread consumes
items from the completion queue and uploads the decoded image data to the GPU.  The point of
doing it this way is so that the main rendering thread is not blocked during the time consuming
process of reading and decoding the PNG files.

<h4><a name="usingrenderer">Using the Renderer</a></h4>

<p>The typical sequence for using the renderer is:

<ol>
<li>set up an entity context, specifying maximum number of entities and child entities, e.g:
<pre>
        instrumentecx = entity_context_new(5000, 1000);
</pre>
<li>set up camera orientation and parameters and calculate camera transform for this context:
<pre>
        camera_assign_up_direction(instrumentecx, camera_up.v.x, camera_up.v.y, camera_up.v.z);
        camera_set_pos(instrumentecx, camera_pos.v.x, camera_pos.v.y, camera_pos.v.z);
        camera_look_at(instrumentecx, 0.0, 0.0, 0.0);
        float near = 0.5;
        float far = 1000.0;
        float angle_of_view = 80;
        camera_set_parameters(instrumentecx, near, far,
                                SCREEN_WIDTH, SCREEN_HEIGHT, angle_of_view * M_PI / 180.0);
        calculate_camera_transform(instrumentecx);
</pre>
<li>Choose a rendering style for this context:
<pre>
        set_renderer(instrumentecx, WIREFRAME_RENDERER);
	/* The 2nd param may OR together several things:  e.g.
	 * FLATSHADING_RENDERER | WIREFRAME_RENDERER | BLACK_TRIS) */
</pre>
Mainly this is choosing between "normal" rendering (FLATSHADING_RENDERER) and some form of
"wireframe", either transparent (WIREFRAME_RENDERER) or non-transparent
(FLATSHADING_RENDERER | WIREFRAME_RENDERER | BLACK_TRIS).
<li>Add entities into the context:
<pre>
	for (i = 0; i < nstarmap_entries; i++) {
		e = add_entity(instrumentecx, torpedo_nav_mesh,
			starmap[i].x - ox, starmap[i].y - oy, starmap[i].z - oz,
			i == our_ss ? UI_COLOR(starmap_home_star) : UI_COLOR(starmap_star));
		update_entity_scale(e, 0.1);
		entity_set_user_data(e, &starmap[i]); /* so we can draw labels later */
	}
</pre>
<li>Render the entities in this context:
<pre>
        render_entities(instrumentecx);
</pre>
<li>Clear out all of the entities from this context (if you are adding and removing them every frame, say):
<pre>
	remove_all_entity(instrumentecx);
</pre>
</ol>

<p>TODO: Elaborate more on the renderer

<h3><a name="guiwidget">GUI widget system</a></h3>

<p>There are a variety of custom "widgets"
used to create the UI: buttons, text input fields, scrolling text windows,
gauges, sliders, and pull down menus.

<p>Each of these has their own set of functions used to create them and modify
and control their behavior. Additionally there are some functions which are
generic and apply to all widget types or to lists of widgets in aggregate.
These generic functions are defined by snis_ui_element.h and snis_ui_element.c

<p>If there is a widget of type XXX, then there is likely a function called
XXX_init() or create_XXX() which returns a pointer to an XXX.

<p>Typically, there is a function to initialize all the widgets associated with
a particular screen, and store all those widget pointers into a structure.
Additionally those widgets are added into a list of all UI objects (uiobjs)
along with a tag indicating which screen those widgets belong to.

<h4><a name="buttons">Buttons / Checkboxes</a></h4>

<ul>
<li>snis_button.h
<li>snis_button.c
</ul>

<h4><a name="textinput">Text input</a></h4>

<ul>
<li>snis_text_input.h
<li>snis_text_input.c
</ul>

<h4><a name="textwindow">Text Window</a></h4>

<ul>
<li>snis_text_window.h
<li>snis_text_window.c
</ul>

<h4><a name="gauges">Gauges</a></h4>

<ul>
<li>snis_gauge.h
<li>snis_gauge.c
</ul>

<h4><a name="sliders">Sliders</a></h4>
<ul>
<li>snis_slider.h
<li>snis_slider.c
</ul>

<h4><a name="pulldownmenus">Pull down menus</a></h4>

<ul>
<li>snis_pull_down_menu.h
<li>snis_pull_down_menu.c
</ul>

<h4><a name="uielements">UI Elements</a></h4>

<ul>
<li>snis_ui_element.h
<li>snis_ui_element.c
</ul>

<h4><a name="uicolors">UI Colors</a></h4>

<ul>
<li>ui_colors.h
<li>ui_colors.c
</ul>

<h3><a name="rolesuis">Roles and station UIs</a></h3>

<h4><a name="netsetup">Network Setup UI</a></h4>

<ul>
<li>Defined by struct network_setup_ui net_setup_ui in snis_client.c
<li>Initialized by function init_net_setup_ui() called from main() in snis_client.c
<li>Function to render the network setup UI is show_network_setup() in snis_client.c
</ul>

<h4><a name="navui">Navigation UI</a></h4>

<ul>
<li>Defined by struct navigation_ui nav_ui in snis_client.c
<li>Initialized by init_nav_ui() called from main() in snis_client.c
<li>Function to render the navigation UI is show_navigation().  The 3D Navigation
display is drawn by draw_3d_nav_display(), and the star map display is drawn by
draw_3d_nav_starmap() in snis_client.c.
</ul>

<h4><a name="weapui">Weapons UI</a></h4>

<ul>
<li>Defined by struct weapons_ui weapons in snis_client.c
<li>Initialized by init_weapons_ui() called from main() in snis_client.c
<li>Function to render the weapons screen is show_manual_weapons(), which
calls show_weapons_camera_view().
</ul>

<h4><a name="engui">Engineering UI</a></h4>

<ul>
<li>Defined by struct engineering_ui eng_ui in snis_client.c
<li>Initialized by init_engineering_ui() called from main() in snis_client.c
<li>Function to render the engineering screen is show_engineering() in snis_client.c
</ul>

<h4><a name="damconui">Damage Control UI</a></h4>

<ul>
<li>Defined by struct damcon_ui damcon_ui in snis_client.c
<li>Initialized by init_damcon_ui() called from main() in snis_client.c
<li>Function to render the damage control screen is show_damcon().
</ul>

<h4><a name="sciui">Science UI</a></h4>

<ul>
<li>Defined by struct science_ui sci_ui in snis_client.c
<li>Initialized by init_science_ui called from main() in snis_client.c
<li>Function to render the science screen is show_science(). The short
range scanners screen is rendered by draw_sciplane_display(). The
long range scanners screen is rendered by show_3d_science(). The waypoints
screen is rendered by draw_science_waypoints().  The details screen is
rendered by draw_science_details() and draw_science_data().
</ul>

<h4><a name="commsui">Comms UI</a></h4>

<ul>
<li>Defined by struct comms_ui comms_ui in snis_client.c
<li>Initialized by init_comms_ui() called from main() in snis_client.c
<li>Function to render the comms screen is show_comms().
</ul>

<h4><a name="demonui">Demon UI</a></h4>

<ul>
<li>Defined by struct demon_ui demon_ui in snis_client.c
<li>Initialized by init_demon_ui() called from main() in snis_client.c
<li>Function to render the demon screen is show_demon(). The 2d demon
screen is drawn by show_demon_2d() and the 3d demon screen is drawn by
show_demon_3d(). The console on the demon screen is rendered by
show_demon_console() -- though it's just unhiding a text box widget.
</ul>

<h4><a name="lobbyui">Lobby UI</a></h4>

<ul>
<li>Defined by struct lobby_ui lobby_ui in snis_client.c
<li>Initialized by init_lobby_ui() called from main() in snis_client.c
</ul>

<h3><a name="kmjinput">Keyboard, Mouse and Joystick Input</a></h3>

<p>Keyboard and mouse input are handled at a low level by SDL which calls
process_events() to handle key presses and key releases and mouse button
presses and mouse motion which dispatches to the following functions:

process_event passes the event to ui_element_list_event() which allows the
custom widgets (buttons, sliders, menus, etc) to potentially process the
event. If the widgets do not consume the event, it may be further processed
as a direct input to the game, as follows:

<ul>
<li>key press - key_press_cb()
<li>key release - key_release_cb()
<li>mouse button press - main_da_button_press()
<li>mouse button release - main_da_button_release()
<li>mouse motion - main_da_motion_notify()
<li>window resize - sng_set_screen_size()
</ul>


<p>There is a struct keyboard_state kbstate variable defined
in snis_keyboard.c and snis_keyboard.h which captures the current
state of the keys/actions that snis_client cares about. There is
also a mapping from keypresses to actions which is configurable.
(This configuration happens in init_keymap() and read_keymap_config_file()
in snis_keyboard.c) The keypress and release callbacks modify kbstate
to reflect the current state of the keyboard.

<p>keymap[] and ffkeymap[] defined in snis_keyboard.h contain
key mappings for each displaymode for normal and modified (ctrl-,
alt- and other combo) keys.

<p>deal_with_keyboard() in snis_client.c consults the state of kbstate
and uses that to initiate actions.

<p>Joystick hardware state is polled via linux ioctl() in joystick.c via
get_joystick_state(), which is called from deal_with_joystick() in
snis_client.c.

<p>The actions which happen when a joystick button or axis event is
detected are configurable to trigger callback functions via
set_joystick_button_fn() and set_joystick_axis_fn().  These are used
in setup_joysticks() in snis_client.c to set callbacks for joystick
axes and functions according to a joystick config file,
share/snis/joystick_config.txt. The joystick
config file is read via read_joystick_config() called from setup_joysticks()
in snis_client.c.  read_joystick_config() is defined by joystick_config.h
and joystick_config.c

<h3><a name="audio">Audio</a></h3>

<p>Audio is controlled via the audio library defined by wwvi_audio.h and wwvi_audio.c,
and ogg_to_pcm.c and ogg_to_pcm.h.
The ogg_to_pcm library can read and decode ogg vorbis files into memory for later playback.
The wwvi_audio library can concurrently playback and mix many samples at once. The samples
must be 44.1Khz MONO samples however. It relies on the portaudio library to communicate
with the audio hardware.

<p>Using the wwvi_audio library typically goes something like this:

<pre>
        if (wwviaudio_initialize_portaudio() != 0)
                bail_out_and_die();

        /* You would probably use #defines or enums rather than bare ints... */
        wwviaudio_read_ogg_clip(1, "mysound1.ogg");
        wwviaudio_read_ogg_clip(2, "mysound2.ogg");
        wwviaudio_read_ogg_clip(3, "mysound3.ogg");
        wwviaudio_read_ogg_clip(4, "mymusic.ogg");

        ...

        wwviaudio_play_music(4); // begins playing music in background, returns immediately

        while (program is not done) {
                do_stuff();
                if (something happened)
                        wwviaudio_add_sound(1);  // plays in background returns immediately
                if (something else happened)
                        wwviaudio_add_sound(2); // plays in background returns immediately
                time_passes();
        }
	wwviaudio_cancel_all_sounds();
	wwviaduio_stop_portaudio();
</pre>


<h3><a name="speechrecog">"The Computer" / Speech Recognition</a></h3>

<p>Pocketsphinx (running as a separate process) or some other speech recognition system
can be used to talk to "the computer" onboard the ship. The output of the speech recognizer
is fed into a fifo /tmp/snis-natural-language-fifo, where it is then processed as already
<a href="#snisclientnlprocthread">described above</a>.

<p>For more details about how this works, see this set of slides:
<a href="https://smcameron.github.io/space-nerds-in-space/snis-nl-slides/slideshow.html#1">Speech Recognition and Natural Language Processing in Space Nerds in Space</a>.
Note: that slide show will probably not work well on mobile devices.  Also I notice github's
html preview seems to break the link, so here it is so you can copy/paste it:

<li>https://smcameron.github.io/space-nerds-in-space/snis-nl-slides/slideshow.html#1

<h3><a name="starmap">Star Map / Warp gate traversal</a></h3>

<p>Each "solarsystem" has a set of coordinates defined in the solarsystem asset file.
These coordinates are initially generated by util/generate_solarsystem_positions.
They are generated such that any one star is not to close to too many stars, nor too
distant from at least one star.  See
<a href="https://github.com/smcameron/space-nerds-in-space/blob/master/doc/howto-add-new-solarsystems">doc/howto-add-new-solarsystems</a>.

<p>starmap_adjacency.h and starmap_adjacency.c contain routines to compute adjacencies
of solarsystems based on the distances between solarsystems computed from the solarsystem
coordinates in the solarsystem asset files on snis_server (possibly transmitted to snis_client
via OPCODE_UPDATE_SOLARSYSTEM_LOCATION.)

<p>These adjacencies determine which stars you can travel to via warpgates from any
given star, and are how snis_client knows what to lines to draw between stars on the
starmap.  The starmap is drawn by the function draw_3d_nav_starmap() in snis_client.c
called by show_navigation(), called by main_da_expose(), called from the main loop
in main(), using the starmap_adjacency[][] array, which is filled in
by starmap_compute_adjacencies() in starmap_adjacency.c called from
process_update_solarsystem_location(), or initially from construct_starmap(), called
from main() in snis_client.c

<p>When the player traverses a warp gate, (player_collision_detection in snis_server.c
calls player_attempt_warpgate_jump() in snis_server.c) it checks to see if the player
has bought a warp gate ticket, and if so, sends an opcode OPCODE_SWITCH_SERVER
to all the snis_client instances for the bridge in question to switch to a new
snis_server instance. This sets a Rube Goldbergian sequence of events in motion.

<p>When a snis_client instance receives OPCODE_SWITCH_SERVER, in gameserver_reader()
in snis_client.c, it reads the operands, which are the warp gate number and new
server location (a string, the solarsystem name), and then
stops the gameserver_writer() thread (this will cause the snis_server end its
corresponding reader thread) The snis_client() then deletes all objects (clears the go[] array)
and deletes all damcon objects, set a switched_server global variable to 1, and
connected_to_gameserver global to 0, and the gameserver_reader thread returns (exits).

<p>In advance_game(), it notices switch_server is 1, and sets a global switch_server2 to 1,
and switch_server to -1, and displaymode to DISPLAYMODE_LOBBYSCREEN.

<p>Since displaymode is DISPLAYMODE_LOBBYSCREEN, show_lobbyscreen() gets called.
it notices it's time to switch servers, and connects to the new server for
the solar system name obtained from OPCODE_SWITCH_SERVER earlier (looking up
the solarsystem name in the information from the lobby server).

<p>There is some additional rigamarole to get the new solarsystem specific textures
(planets, skybox, central star, etc.) loaded. main_da_expose() calls load_textures
(which most times does nothing, as everything is already loaded most times).

<p>load_textures() calls load_per_solarsystem_textures(), which checks if they are
already loaded before continuing.  If not, then it checks if it's in a new solarsystem
and if so, calls reload_per_solarsystem_textures(). This marks the old solarsystem textures
as "expired". then sets per_solarsystem_textures_loaded = 0, and then the next time
through the new textures will be loaded and the old ones will be discarded.

<h3><a name="voicechat">Voice Chat</a></h3>

<p>Space Nerds in Space has a voice chat feature in which the user can press F12
and the microphone will be recorded until F12 is no longer pressed, and the audio
will be compressed and sent to the server where it will be forwarded to the other
clients of the bridge and decompressed and played on those players' stations.

<p>For voice chat, I needed more than just the simple playback of preloaded sounds
that was implemented up to this point.

<ul>
<li>We need to make sure the number of concurrent streams sent to a client from
from the server does not exceed the number of streams the client can handle.
<li>We need the ability to record sound, and receive a stream of audio data
from the microphone as a series of callbacks.
<li>We need the ability to compress these packets and send them to my server
process. For this I used libopus.
<li>We need the server to forward these packets to destination clients, keeping
in mind that there might be multiple clients streaming audio to the server, and
these would need to be then fanned back out to the destination clients. The
streams would need to be kept separate though, because the decompressor is
stateful, and you can’t combine multiple streams of packets and send them
through a single decompressor instance. They each need their own decompressor.
<li>At the clients, we need to receive the audio data streams from the server
and decompress them, and queue them up for the mixer to chew on.
</ul>

<p>To ensure that clients never receive more streams of audio than they can
handle, a token system is used.

<ul>
<li><a href="https://github.com/smcameron/space-nerds-in-space/blob/master/talking_stick.h">talking_stick.h</a>
<li><a href="https://github.com/smcameron/space-nerds-in-space/blob/master/talking_stick.c">talking_stick.c</a>
</ul>

<p>There is one token for each audio channel the clients are able to handle
(nominally, there are 4 of them.) Just before clients begin recording and
transmitting audio data to the server, they request a token from the server.
They then transmit to the server (whether or not they eventually get the token)
knowing that if they don’t get a token, the server will just drop their
packets. The server has a fixed number of token which it assigns to the clients
as they ask for them until they are all in use. If the server receives any
audio packets from clients which it knows do not have a token, it just drops
those packets. In this way, the server never transmits more streams of audio
than the clients can handle.

<p><h4>Recording audio</h4>

<p>Recording is triggered by a keypress event, and terminated by a key release
event, as it is a “push to talk” system. Pressing the key requests a token from
the server (but doesn’t wait for it to be given) and starts the recording
process, which sets up a portaudio thread reading from the microphone and
periodically calling back a function passing along the PCM audio data that was
recorded 1920 samples at a time (at a sampling rate of 48000 Hz). (I chose 1920
and 48kHz because these are reasonable values supported by libopus. This did
mean I had to resample my existing audio files from 44.1kHz to 48kHz.)

<p>We transmit without waiting for the token from the server so that the
instant the token is given (before the client even receives it) the server may
begin accepting audio packets from the client. Also it’s easier to code as we
do not need to write any code to wait for the token.

<p>The code for that looks like this:
<pre>
        if (keysym-&gt;sym == SDLK_F12) {
                pthread_mutex_lock(&amp;voip_mutex);
                        if (!have_talking_stick) {
                                pthread_mutex_unlock(&amp;voip_mutex);
                                request_talking_stick();
                        } else {
                                pthread_mutex_unlock(&amp;voip_mutex);
                        }
                /* We transmit regardless of whether we have a talking stick.
                 * If we do not have it, snis_server will drop our messages */
                if (control_key_pressed)
                        voice_chat_start_recording(VOICE_CHAT_DESTINATION_ALL, 0);
                else
                        voice_chat_start_recording(VOICE_CHAT_DESTINATION_CREW, 0);
        }
</pre>

<p>voice_chat_start_recording() ultimately starts up a portaudio thread to
begin recording data and calling the recording_callback function described
below.

<p>This recording callback function cannot directly just compress and transmit
the data to the server, as it might conceivably fall behind the recording
process if say, writing to the network socket blocks or is slow. So it puts the
data into an “outgoing” queue and returns. It looks like this:
<pre>
static void recording_callback(void *cookie, int16_t *buffer, int nsamples)
{
        if (nsamples != VC_BUFFER_SIZE)
                return;
        recording_buffer.nsamples = nsamples;
        if (recording_audio)
                recording_level = get_max_level(&amp;recording_buffer);
        else
                recording_level = 0;
        pthread_mutex_lock(&amp;outgoing.mutex);
        enqueue_audio_data(&amp;outgoing, recording_buffer.audio_buffer, recording_buffer.nsamples,
                        recording_buffer.destination, recording_buffer.snis_radio_channel);
        pthread_mutex_unlock(&amp;outgoing.mutex);
}
</pre>

<p>When the “transmit” key is released, the portaudio recording thread is
stopped, and if the client is in possession of any token, it is released to the
server where it may then be handed out again to whichever client asks for a
token.
<pre>
        if (keysym-&gt;sym == SDLK_F12) {
                voice_chat_stop_recording(); /* This shuts down the portaudio thread that was recording. */
                /* We release even if we don't have, snis_server will know the real deal. */
                release_talking_stick();
        }
</pre>

<p><h4>Compressing audio</h4>

<p>There is then another thread that consumes audio data from this outgoing
queue, compresses it with libopus, then sends it on to the server. The meat of
that function looks like this:
<pre>
        while (1) {

                /* Get an audio buffer from the queue */
                pthread_mutex_lock(&amp;q-&gt;mutex);
                b = dequeue_audio_buffer(q);
                if (!b) {
                        rc = pthread_cond_wait(&amp;q-&gt;event_cond, &amp;q-&gt;mutex);
                        if (q-&gt;time_to_stop) {
                                pthread_mutex_unlock(&amp;q-&gt;mutex);
                                goto quit;
                        }
                        pthread_mutex_unlock(&amp;q-&gt;mutex);
                        if (rc != 0)
                                fprintf(stderr, "pthread_cond_wait failed %s:%d.\n", __FILE__, __LINE__);
                        continue;
                }
                pthread_mutex_unlock(&amp;q-&gt;mutex);
/* ... */
                /* Encode audio buffer */
                len = opus_encode(encoder, b-&gt;audio_buffer, VC_BUFFER_SIZE, b-&gt;opus_buffer, OPUS_PACKET_SIZE);
                if (len &lt; 0) { /* Error */
                        fprintf(stderr, "opus_encode failed: %s\n", opus_strerror(len));
                        goto quit;
                }

                /* Transmit audio buffer to server */
                transmit_opus_packet_to_server(b-&gt;opus_buffer, len, b-&gt;destination, b-&gt;snis_radio_channel);
                free(b);
        }
</pre>
<p>The function that does the compression is opus_encode(), and
transmit_opus_packet_to_server() transmits the compressed audio to the server.

<p><h4>Receiving and routing the audio on the Server</h4>

<p>When the server receives a packet of compressed audio from a client, it
knows which client it came from (because of which socket it came in on and
which thread is monitoring that socket), and which token, if any that client
currently possesses (because if the client has a token, it’s because the server
gave the client the token and remembers which one, or if it didn’t give it
one).

<p>If the client does not have a token, the packet is dropped. If it does have
a token, then this token determines which of the 4 audio channels this data
belongs to, and the data is fanned out to the destination clients along with
the token number. The client which sent the data is generally excluded from
receiving its own audio data back, as there’s no point in repeating back to
them what they just said but with a slight delay.

<p>That code looks like this:
<pre>
        pthread_mutex_lock(&amp;universe_mutex);
        client_lock();
        if (c-&gt;talking_stick == NO_TALKING_STICK) {
                /* Client does not have talking stick. */
                client_unlock();
                pthread_mutex_unlock(&amp;universe_mutex);
                return 0;
        }
        /* Ignore audio chain from client, it put NO_TALKING_STICK there anyway 'cause it doesn't know */
        audio_chain = c-&gt;talking_stick;
        client_unlock();
        pthread_mutex_unlock(&amp;universe_mutex);
        pb = packed_buffer_allocate(10 + datalen);
        packed_buffer_append(pb, "bhbwhr", OPCODE_OPUS_AUDIO_DATA,
                                (uint16_t) audio_chain, destination, radio_channel, datalen, buffer, datalen);

        /* Don't send a client's own audio back at him. */
        except.nclients = 1;
        except.client[0] = c - &amp;client[0];
        except.shipid[0] = c-&gt;shipid;

        switch (destination) {
        case VOICE_CHAT_DESTINATION_CREW:
                send_packet_to_all_clients_on_a_bridge_except(c-&gt;shipid, pb, ROLE_ALL, &amp;except);
                break;
        case VOICE_CHAT_DESTINATION_ALL:
        case VOICE_CHAT_DESTINATION_CHANNEL: /* TODO: implement radio channels */
                send_packet_to_all_clients_except(pb, ROLE_ALL, &amp;except);
                break;
        default:
                fprintf(stderr, "Unexpected destination code %hhu in opus audio packet\n", destination);
                return -1;
        }
</pre>

<p><h4>Decompressing and playing back data</h4>

<p>When the client receives audio data, it is put into an “incoming” queue. The
data is accompanied by a token number.
<pre>
void voice_chat_play_opus_packet(uint8_t *opus_buffer, int buflen, int audio_chain)
{
        if (buflen &gt; VC_BUFFER_SIZE)
                buflen = VC_BUFFER_SIZE;
        if (audio_chain &lt; 0 || audio_chain &gt; WWVIAUDIO_CHAIN_COUNT)
                return;
        pthread_mutex_lock(&amp;incoming.mutex);
        enqueue_opus_audio(&amp;incoming, opus_buffer, buflen, audio_chain);
        pthread_mutex_unlock(&amp;incoming.mutex);
}
</pre>

<p>The “incoming” queue is consumed by a thread for decoding the audio packets.
The thread uses the token number for each audio packet to determine which of
the 4 opus decoders (decompressors) is used to decompress the data. The opus
decoders are stateful, and their state depends on previously decoded packets,
so it is important not to interleave packets from different clients into a
decoder.

<p>Once the data is decompressed, it is appended to one of the 4 chains of VOIP
audio data the mixer consumes according to the token number.

<p>The meat of that code looks like this:
<pre>
        while (1) {

                /* Get an audio buffer from the queue */
                pthread_mutex_lock(&amp;q-&gt;mutex);
                b = dequeue_audio_buffer(q);
                if (!b) {
                        rc = pthread_cond_wait(&amp;q-&gt;event_cond, &amp;q-&gt;mutex);
                        if (q-&gt;time_to_stop) {
                                pthread_mutex_unlock(&amp;q-&gt;mutex);
                                goto quit;
                        }
                        pthread_mutex_unlock(&amp;q-&gt;mutex);
                        if (rc != 0)
                                fprintf(stderr, "pthread_cond_wait failed %s:%d.\n", __FILE__, __LINE__);
                        continue;
                }
                pthread_mutex_unlock(&amp;q-&gt;mutex);

                /* decode audio buffer */
                i = b-&gt;audio_chain;
                len = opus_decode(opus_decoder[i], b-&gt;opus_buffer, b-&gt;nopus_bytes, b-&gt;audio_buffer, VC_BUFFER_SIZE, 0);
                if (len &lt; 0) {
                        fprintf(stderr, "opus_decode failed\n");
                        goto quit;
                }
/* ... */
                playback_level = get_max_level(b);

                /* If it's been a couple seconds since we've seen data on this chain then
                 * inject 100ms of silence ahead of the data to put the mixer 100ms behind
                 * it so that if there's jitter or some space between subsequent packets,
                 * there's a little bit of slack before the mixer runs out.
                 */
                mcc = wwviaudio_get_mixer_cycle_count();
                difference = mcc - last_mixer_cycle_count[b-&gt;audio_chain];
                if (difference &gt; (4 * 48000) / VC_BUFFER_SIZE &amp;&amp; difference &lt; (unsigned int) 0xfffff000)  {
                        /* &gt; about 4 seconds at VC_BUFFER_SIZE samples per mixer cycle */
                        /* &lt; 0xfffff000 to avoid hiccup at mcc wraparound */
                        wwviaudio_append_to_audio_chain(short_silence, ARRAYSIZE(short_silence),
                                                        b-&gt;audio_chain, NULL, NULL);
                }
                last_mixer_cycle_count[b-&gt;audio_chain] = mcc;

                /* Let the mixer have the data */
                wwviaudio_append_to_audio_chain(b-&gt;audio_buffer, len, b-&gt;audio_chain, free_audio_buffer, b);
        }
</pre>
<p><h4>Mixing the audio</h4>

<p>The mixer mixes several (about 10-20) channels of data dedicated for
preloaded sound effects and 4 channels of VOIP data. The VOIP data is in the
form of a linked list. When one chunk of audio data is consumed the mixer calls
a callback function associated with that data (typically used to free the
buffers containing the data) and then the mixer moves on to the next chunk in
the linked list. Data may be appended to the list at any time by the thread
doing decompression of audio data incoming from the network.

<p>The mixer function is quite complex, but it’s <a href="https://github.com/smcameron/space-nerds-in-space/blob/master/wwviaudio.c#L236">here</a>.


<h2><a name="snisserver">SNIS Server</a></h2>
<h3><a name="snisserveroverview">Overview<a/></h3>
<p>snis_server runs a simulation of a solarsystem. You can run multiple instances
of snis_server on a single machine, or on different machines. snis_server has no
UI to speak of, all interaction with snis_server happens through snis_client.
Each snis_client process connected to a snis_server is part of a bridge. Multiple
bridges may exist within snis server, and each snis_client is part of exactly one
of those bridges. As the simulation progresses, various information is sent to
each snis_client process such as the power settings, coolant level, and damage
of all the systems on the bridge, the ship's location and orientation in the solar
system, the positions and orientations of all the NPC ships, asteroids, planets,
black holes, etc. in the solar system.  The simulation ticks at 10Hz, and updates
cycles are begun at 10Hz.

<h3><a name="snisserverdatastr">Main Data Structures</a></h3>

<h4><a name="snisserverclientarr">client[] array</a></h4>

<p>This array defined in snis_server.c has one entry per connected snis_client process,
and holds information about the client, such as the file descriptor for the TCP socket
connected to the client, the threads for reading and writing to the client socket, a
queue to contain packets to be sent to the client and a mutex to protect that queue,
and on and on.

<pre>
static struct game_client {
	int socket;		/* socket to connect snis_client process */
	pthread_t read_thread;	/* thread for reading from snis_client */
	pthread_t write_thread; /* thread for writing to snis_client */
	struct packed_buffer_queue client_write_queue; /* queue of packets to be writtent to snis_client */
	pthread_mutex_t client_write_queue_mutex;	/* mutex to protect client_write_queue */
	uint32_t shipid;	/* ID of player ship for this snis_client */
	uint32_t ship_index;	/* Index into go[] for player ship for this client */
	uint32_t role;		/* bitmap of roles this snis_client has set */
	uint32_t timestamp;	/* The universe_timestamp when this client was last updated, */
				/* see queue_up_client_updates() */
	int bridge;		/* index into bridgelist[] for the bridge this client is on. */
	int debug_ai;		/* Whether or not to transmit NPC ai debug info to this client */
	struct snis_entity_client_info *go_clients; /* ptr to array of size MAXGAMEOBJS. Contains a timestamp */
				/* for each object indicating when that obj was last updated to this client */
	struct snis_damcon_entity_client_info *damcon_data_clients; /* ptr to array of size MAXDAMCONENTITIES */
				/* Contains timestamps for last update time of damcon objs for this client */
	uint8_t refcount; /* count of threads using this client structure. When 0, can delete. see put_client(). */
	int request_universe_timestamp; /* Used for sending timestamp samples to client to gauge latency */
	char *build_info[2]; /* version/endianness etc. of client, see gather_build_info script, string1, and string2 */
	uint32_t latency_in_usec; /* network latency, visible via demon screen */
	int waypoints_dirty;	/* trigger update of waypoints to client. If one client updates */
				/* waypoints, all clients need to see that update */
	uint8_t current_station; /* what station (displaymode) client is currently on. Mostly the server doesn't */
				/* need to know this, but uses it for demon serverside builtin commands "clients" */
				/* "lockroles", and "rotateroles" */
#define COMPUTE_AVERAGE_TO_CLIENT_BUFFER_SIZE 0
#if COMPUTE_AVERAGE_TO_CLIENT_BUFFER_SIZE
	uint64_t write_sum;	/* Statistics about data written to client */
	uint64_t write_count;
#endif
} client[MAXCLIENTS];
static int nclients = 0; /* number of entries in client[] that are active */
#define client_index(client_ptr) ((long) ((client_ptr) - &amp;client[0]))
static pthread_mutex_t client_mutex = PTHREAD_MUTEX_INITIALIZER; /* protects client[] array */
</pre>

<h4><a name="snisserverbridgelist">bridgelist[] array</a></h4>

<p>There is one element of the bridgelist array for each bridge. When the first
snis_client instance for a particular bridge connects to snis_server, a new element
is created. Subsequently connecting snis_client instances for that bridge share
the same element. The bridgelist[] array is defined in snis_server.c.

<pre>
static struct bridge_data {
	unsigned char shipname[20];	/* Name of this ship */
	unsigned char password[20];	/* Password for this ship (plaintext) */
	uint32_t shipid;		/* ID of this ship */
	struct damcon_data damcon;	/* All the damage control objects for this ship */
	int last_incoming_fire_sound_time; /* prevents incoming fire warning from sounding too frequently */
	double warpx, warpy, warpz;	/* Holds coordinates related to warp drive. See maybe_do_player_warp() and */
					/* do_engage_warp_drive() */
	union vec3 warpv;		/* warp vector. 1/50th of the distance of the warp in direction of warp */
	int warptimeleft;		/* How many ticks left for warp travel? See maybe_do_player_warp() */
	int comms_channel;		/* Current channel number comms will transmit/receive on */
	struct npc_bot_state npcbot;	/* Context for NPC comms to maintain conversation */
	int last_docking_permission_denied_time; /* rate limits "docking permission denied" messages */
	uint32_t science_selection;	/* ID of currently selected item on science station */
	int current_displaymode;	/* what the main screen(s) of the bridge are currently showing, */
					/* See process_role_onscreen() */
	struct ssgl_game_server warp_gate_ticket; /* ssgl server entry of the snis_server to which player has */
					/* bought a warp gate ticket. */
	unsigned char pwdhash[PWDHASHLEN]; /* hash of ship name+password+salt, used to identify ships */
					/* to/from multiverse server */
	int verified; /* whether this bridge has verified with multiverse server */
#define BRIDGE_UNVERIFIED 0
#define BRIDGE_VERIFIED 1
#define BRIDGE_FAILED_VERIFICATION 2
#define BRIDGE_REFUSED 3
	int requested_verification; /* Whether we've requested verification from multiverse server yet */
	int requested_creation; /* whether user has requested creating new ship */
	int nclients;			/* Number of connected clients that are part of this bridge */
	struct player_waypoint waypoint[MAXWAYPOINTS]; /* list of science waypoints created for this bridge */
	int selected_waypoint;		/* Currently selected waypoint (or -1 if none) for this bridge */
	int nwaypoints;			/* Number of waypoints created for this bridge */
	int warp_core_critical_timer;	/* Time (ticks) until warp core explodes */
	int warp_core_critical;		/* Is the warp core going to explode? */
	char last_text_to_speech[256];  /* last uttered speech, used to answer "/computer what", See nl_repeat_n() */
	uint32_t text_to_speech_volume_timestamp; /* last time we adjusted computer volume */
	float text_to_speech_volume;	/* Current computer volume */
	uint8_t active_custom_buttons;	/* Number of active custom buttons, see l_enable_custom_button() */
	char custom_button_text[6][16]; /* Text of custom buttons. See queue_up_client_custom_buttons(), */
					/* and l_set_custom_button_label() */
	/* ship id chips are used for collecting bounties */
#define MAX_SHIP_ID_CHIPS 5
	uint32_t ship_id_chip[MAX_SHIP_ID_CHIPS]; /* The ship ID chips players on this bridge have collected */
	int nship_id_chips;		/* Count of ship ID chips, number of ship_id_chip[] entries that are valid */
} bridgelist[MAXCLIENTS];
static int nbridges = 0;		/* Number of elements present in bridgelist[] */

</pre>

<h4><a name="snisservergo">go[] array</a></h4>

<p>The "go" array, or "game object" array is a list of all the things with which you can
interact in the space simulation.  It contains one element for each NPC spaceship, starbase,
asteroid, planet, black hole, nebula, etc. within the game. The go[] array is declared in
snis_server.c.  The go[] array is protected from concurrent access by the universe_mutex.

<pre>
static struct snis_object_pool *pool;
static struct snis_entity go[MAXGAMEOBJS];
#define go_index(snis_entity_ptr) ((long) ((snis_entity_ptr) - &amp;go[0]))
</pre>

The type of each element is struct snis_entity, which is defined in snis.h

<pre>
struct snis_entity {
	uint32_t id;		/* unique ID of the object (unique within snis_server, and snis_client */
	double x, y, z;		/* coordinates of object in space */
	double vx, vy, vz;	/* velocity of object */
	double heading;		/* heading of the object (archaic?) */
	uint16_t alive;		/* when 0, object is no longer alive */
	uint32_t type;		/* what kind of object is this? See OBJTYPE_* defines, above */
	uint32_t respawn_time;	/* Used in different ways for respawning player ship, and NPC ships */
	union type_specific_data tsd; /* data particular to the type of object */
	move_function move;	/* function to move the object. Varies by object type, and there */
				/* are client and server versions of these functions */
	struct snis_entity_science_data sdata; /* "science" data. Name, type, and shield data */
	union quat orientation; /* Orientation of an object */

#ifdef SNIS_SERVER_DATA
	/* This data only exists on the server */
	uint32_t timestamp;	/* last tick something important about this object changed. Used */
				/* to know if we need to transmit something about this object to */
				/* clients */
	struct space_partition_entry partition; /* Used for collision detection, see space-part.h, space-part.c */
#endif

#ifdef SNIS_CLIENT_DATA
	/* This data only exists on the client */
	struct entity *entity;	/* Corresponding renderer entity */
	int nupdates;		/* number of times this object has been updated. Used for interpolation */
				/* see move_object() in snis_client.c */
	double updatetime[SNIS_ENTITY_NUPDATE_HISTORY]; /* last 4 update timestamps */
	union vec3 r[SNIS_ENTITY_NUPDATE_HISTORY];	/* last 4 object x,y,z positions */
	union quat o[SNIS_ENTITY_NUPDATE_HISTORY];	/* last 4 object orientations */

	struct snis_entity *shading_planet;	/* if object is in shadow of planet, shading_planet will */
				/* point to the planet that casts the shadow on the object. Otherwise null */
				/* See calls to entity_set_in_shade() in snis_client.c, and in_shade parameter */
				/* of graph_dev_raster_texture() in graph_dev_opengl.c */
#endif
	char ai[6];		/* really hacky NPC AI debug data */
};
</pre>
<h3><a name="snisserverthreads">snis_server Threads</a></h3>
<h4><a name="snisserverlistenerthr">snis_server Listener thread</a></h4>
<p>The listener thread is started by start_listener_thread() in snis_server.c, called
from main(). The thread function is listener_thread_fn() in snis_server.c. It enters
an indefinite loop in which it listens on a random port for incoming connections.
When an incoming connection is accepted, service_connection() in snis_server.c is
called. service_connection() selects a free entry in the client[] array for this
client and initializes it, and creates two new threads, one to read and one to
write to the new client connection (See below).

<p>Meanwhile, once the listener thread has been started, the randomly selected portnumber
is communicated to ssgl_server elsewhere (See below).

<h4><a name="sniserverreadwritethr">snis_server Client reader and writer threads</a></h4>

<p>Threads to read and write to clients are started by service_connection() called
from listener_thread_fn() as described above. The read thread function is per_client_read_thread()
which is passed a pointer to the correct element of the client[] array. The write thread
function is per_client_write_thread(), also passed the pointer to the appropriate client[] element.

<p>per_client_read_thread() enters an indefinite loop in which it calls process_instructions_from_client().
process_instructions_from_client() reads an opcode from the client via c-&gt;socket,
then a big switch statement calls the appropriate
function to process that opcode (which involves reading any operands the opcode might have, and doing
whatever the opcode requires.)

<p>per_client_write_thread() periodically transmits data to the client. It enters an indefinite
loop then checks the current time and either sleeps until it is time to transmit data, or transmits
data then sleeps (up to 1/40th of a second, or 25ms) until the next time to transmit data. To
transmit the data, it calls queue_up_client_updates() followed by write_queued_updates_to_client().

<p>queue_up_client_updates() loops through all the elements of the go[] array and queues up
updates for that object to the client if there is anything to update (which depends on a
few things, but mostly on the object's modification timestamp and the last time the object's
data was sent to the client. Remember, each element of the client[] array contains a go_clients[]
array which tracks the last time that object was sent to that client).

<p>queue_up_client_object_update() is the function to package up an object's data to be sent
to the client. It's a big switch statement based on object type which packages up each type
of object's data.

<p>queue_up_client_object_sdata() packages up each objects "sdata" (science data).

<p>And more data is queued up:

<pre>
	queue_up_client_damcon_update(c);
	queue_up_client_waypoint_update(c);
	queue_up_client_rts_update(c);
	queue_up_client_volume_update(c);
	queue_up_client_custom_buttons(c);
</pre>

<p>At the bottom of all (or most) of these queue_up_client_blah_blah() functions is pb_queue_to_client()
to add generic packets into the client's outgoing queue. ("pb" stands for packed_buffer). The queue
that all this data is packed into is c-&gt;client_write_queue,
where c is a pointer to an element of the client[] array. The queue is protected by
c-&gt;client_write_queue_mutex.

<p>Once all the data is queued up, per_client_write_thread() calls write_queued_updates_to_client().
A timestamp opcode is put at the head of the client write queue for latency measuring purposes, and
then all the packed buffers in the client write queue are combined into a single giant packed buffer.
Then this giant packed buffer is written into the client socket via snis_writesocket() in
snis_socket_io.c

<p>Note that per_client_write_thread() is not the only way that
data may enter the per-client write queues. For example, if a torpedo moves and hits a player ship,
then, among other things, an opcode to play a sound will be sent to the player ship
(see snis_queue_add_sound()) and this happens outside of per_client_write_thread(). That is to say,
when per_client_write_thread transmits the contents of c-&gt;client_write_queue to the client,
there are likely things in that queue that per_client_write_thread did not put there.

<h4><a name="snisservermvreadwritethr">snis_server Multiverse reader and writer threads</a></h4>

<p>snis_multiverse facilitates players traversing from one solarsystem to another,
and for preserving ship state between snis_client invocations, and for ensuring that
players don't create a new ship with the same name and password as an existing ship.

<p>snis_server must communicate with snis_multiverse and snis_client(s) to make
all this happen.

<p>The multiverse reader thread function is multiverse_reader() in snis_server.c.
It is started from connect_to_multiverse() in snis_server.c which is in turn called
from servers_changed_cb() in snis_server.c. (See below).

<p>multiverse_reader() enters an indefinite loop in which it reads an opcode
from the snis_multiverse socket, then via a switch statement, calls an appropriate
function to process that opcode and its operands.

<p>There are only a few opcodes that snis_multiverse sends to snis_server,
defined in snis_multiverse.h.

<p>the multiverse writer thread function is multiverse_writer() in snis_server.c.
It is started from connect_to_multiverse(0 in snis_server.c which is in turn called
from servers_changed_cb() in snis_server.c. multiverse_writer just loops, waiting
for packets to be queued, and then writing those packets to the multiverse server.
Packets are queued elsewhere via queue_to_multiverse().

<p>There is a rather horrendously complicated handshaking that happens between
snis_server and snis_multiverse to determine what to do. If the player has
just traversed a warpgate into a new solarsystem, snis_multiverse must transmit
the bridge state to be carried over from the old snis_server to the bridge in
the new snis_server.  Otherwise, we're starting fresh in a snis_server instance,
and snis_server must transmit the bridge state to snis_multiverse.  There's some
verification of intentions regarding creating a new ship vs. joining an existing
ship that happens as well.

<p>TODO: describe this horrendously complicated stuff more clearly.

<h4><a name="snisserverssglthr">snis_server SSGL thread (Lobby thread)</a></h4>

<p>There is a thread (lobbythread) in snis_server.c created by register_with_game_lobby()
by calling ssgl_register_gameserver().  This thread periodically sends the IP
address and port that snis_server is listening on, along with some other information
(e.g. some identifying strings like the solarsystem name) to the ssgl_server process.
This happens in update_lobby_thread() in ssgl/ssgl_register_gameserver.c

<p>By this means ssgl_server maintains a current list of running snis_servers.

<h4><a name="snisserversrvrtrkr">snis_server Server Tracker thread</a></h4>

<p>main() calls server_tracker_start() in snis_server_tracker.c which
starts the server tracker thread.

<p>The server tracker thread connects to the lobby server, and maintains
two lists, one for the current snis_servers and one for the current
snis_multiverse servers.  It updates these lists (by polling the lobby
server) every 20 seconds (unless either list is empty, in which case it
updates these lists every 1 second. Whenever either list changes (what
it receives from the lobby server is different than what it previously
had recorded) it will call the callback function, servers_changed_cb()
in snis_server.c.

<p>servers_changed_cb() will cause snis_server to (possibly disconnect
from an old multiverse_server and then) connect to the current multiverse
server via connect_to_multiverse().

<p>servers_changed_cb() will also call update_starmap() if the list of
snis_servers has changed, which will update the starmap[] array and
mark it dirty (so it will be transmitted to snis_client(s)).

<p>The server tracker thread runs until server_tracker_stop() is called.

<h4><a name="snisservermainthr">Main thread</a></h4>

<p>The main thread of snis_server.c obviously starts with main().
In the beginning, there is a lot of initialization and reading config
files, processing command line options etc, and then the universe is
created by calling make_universe() which populates the go[] array
with a variety of objects.

<p>The listener thread is started, it registers with ssgl_server and creates
the lobby thread and server tracker thread, then it enters the main loop,
near the bottom of main().

<p>In the main loop, it gets the current time and then either waits for
the next tick (10Hz) or does the following:

<pre>
	move_objects(nextTime, discontinuity);
	process_lua_commands();
	rts_ai_run();
	update_multiverse_bridge_count(currentTime);
</pre>

<p>move_objects loops through all the live go[] elements and calls their go[i]-&gt;move()
function, and for player ship objects (OBJTYPE_SHIP1), possibly queues the current
bridge state to be sent to snis_multiverse. It may respawn dead player ships.
Then it moves all the damage control entities on all the bridges. Then it handles
Lua comms transmissions, timers, callbacks, and proximity checks.

<p>process_lua_commands() executes any lua scripts that are queued up.

<p>rts_ai_run() runs the real-time-strategy AI, if rts_mode is turned on.

<p>update_multiverse_bridge_count() queues the current number of bridges running
in this snis_server instance to be sent to snis_multiverse. (This is to allow
snis_multiverse to "autowrangle" (automatically start and stop) snis_server instances.
When the number of bridges in a snis_server instance drops to zero, and the snis_server
instance is not adjacent to any other snis_server instance with at least one bridge
running, then snis_multiverse can safely shut down that snis_server instance.)

<h3><a name="snisserverplayership">Player ship systems</a></h3>

<h4><a name="snisserverpwrcool">Power and coolant models</a></h4>

<p>The power and coolant models are based on an electric circuit model.
The code is in power-model.h and power-model.c.

<pre>
             R01        R02        R03
 +---------/\/\/-------------------/\/\/--------+ S0
 |                                              |
 |           R11        R12         R13         |
 +---------/\/\/-------------------/\/\/--------+ S1
 |                                              |
 |           R21        R22         R23         |
 +---------/\/\/-------------------/\/\/--------+ S2
 |                                              |
 |           R31        R32         R33         |
 +---------/\/\/-------------------/\/\/--------+ S3
 |                                              |
 |           R41        R42         R43         |
 +---------/\/\/-------------------/\/\/--------+ S4
 |                                              |
 |           R51        R52         R53         |
 +---------/\/\/-------------------/\/\/--------+ S5
 |                                              |
 |           R61        R62         R63         |
 +---------/\/\/-------------------/\/\/--------+ S6
 |                                              |
 |                                              |
 |      RS        | | | |                       |
 +----/\/\/------||||||||-----------------------+
                  | | | |
                    V0, Imax
</pre>
<P>The power supply is a constant voltage supply with a limited
maximum current.   Each row of three resistors represents a
system.  R*1 is a variable resistor controlled by crewmembers
and specific to a device, e.g. Warp power setting, or phaser
power setting.   R*2 is a limit on R*1 controlled by engineering
to control power consumption of a system, R*1 is not allowed to
be a value below R*2, so engineering can limit the current consumed
by a device.   R*3 is the innate resistance of the device.
Some devices may have a constant R*1 (not user controllable), and
then it is only engineering which controls the power consumption
of the device.  r*3 is typically a constant.

<p>The code that uses the power model code is in snis_server.c.  The
power model is set up in init_power_model(), and the coolant model is
set up in init_coolant_model().

<p>Note that the values passed to int_power_model() are somewhat
carefully tuned. See snis.h:

<pre>
/* Careful, CURRENT / VOLTAGE ratio is twitchy, keep it in the sweet spot
 * MAX_CURRENT between 5 and 10, MAX_VOLTAGE at 1000000.0.
 */
#define MAX_CURRENT 6.5
#define MAX_COOLANT 10
#define MAX_VOLTAGE 1000000.0
#define INTERNAL_RESIST 0.00000
</pre>

<p>Periodically (at 10Hz tick rate) the power and coolant models are advanced
by do_power_model_computations and do_coolant_model_computations() which call
power_model_compute(). These advance the model towards a new steady state,
taking into account user input changes to resistor values (ultimately linked to
sliders in the UI). These new current and temperature values are then extracted
from the power and coolant models via device_power_byte_form() in snis_server.c
which computes a ratio of the device current to the device maximum current and
scales this into the range 0-255.  These byte values for all the different
systems are then stored in o-&gt;tsd.ship.power_data.<em>system</em>.i and
o-&gt;tsd.ship.coolant_data.<em>system</em>.i, where o is pointer to the
player's ship's struct snis_entity, and where <em>system</em> is one of
the systems on the ship, such as the warp drive, the shields, the impulse
drive, etc.

<p>Damage to a device is modeled as a fractional reduction in current for
the device plus a random reduction, both of which vary proportionally to the
amount of damage. (see power_device_set_damage() and device_current() in
power-model.c)

<p>You might notice that on the damage control screen, each of the systems on
the ship has three separate components that can be separately damaged and repaired.
Really, there is just a single byte representing the damage to a system. This
real damage to each system is spread out randomly among that system's three components
by distribute_damage_to_damcon_system_parts() in snis_server.c. Going the other way,
changes to damage values due to repairs to the individual components are gathered
up and accumulated into the single byte values in
o-&gt;tsd.ship.damage.<em>system</em>.i in move_damcon_entities_on_bridge() in
snis_server.c:

<pre>
	for (i = 0; i &lt;= nobjs; i++) {

		[... much omitted ... ]

		damage[part-&gt;tsd.part.system] +=
			(float) part-&gt;tsd.part.damage / (float) DAMCON_PARTS_PER_SYSTEM;
	}

	[... much omitted ...]

	for (i = 0; i &lt; DAMCON_SYSTEM_COUNT - 1; i++) {
		unsigned char *x = (unsigned char *) &amp;o-&gt;tsd.ship.damage;
		if (x[i] != (unsigned char) damage[i]) {
			x[i] = (unsigned char) damage[i];
			changed = 1;
		}
	}
</pre>




<p>The user adjustable resistance values in the power model are linked to byte values
within struct snis_entity through sampling callbacks (see new_power_device() and
power_model_update_resistances() in power-model.c) In snis_server.c, these sampling
callbacks are created by the DECLARE_POWER_MODEL_SAMPLER macro, and passed to
new_power_device() via the POWERFUNCS macro to sample byte values within snis_entity
that are in turn controlled via the network by the UI in snis_client.c

<p>

<h4><a name="snisservercollision">Collision detection</a></h4>

<p>Collision detection is implemented with a space partitioning scheme
that is defined by space-part.h and space-part.c

<p>Space is divided into a 2D grid. Any time a collidable object (a snis
entity) is moved, its grid cell is updated with its presence, so at any
time any grid cell knows exactly which snis_entities lie within it. This is
done via set_object_location() in snis_server.c, which calls space_partition_update()
for the object.  Any time an object's location is changed, set_object_location
is used (the coordinates are never changed directly).

<p>In snis_server.c, in main(), there's this code:

<pre>
        space_partition = space_partition_init(40, 40,
                        -UNIVERSE_LIMIT, UNIVERSE_LIMIT,
                        -UNIVERSE_LIMIT, UNIVERSE_LIMIT,
                        offsetof(struct snis_entity, partition));
</pre>

<p>This sets up a 40 x 40 space partitioning grid.

<p>To see if an object is colliding, space_partition_process() is called.
For any object, there are only 4 grid cells which must be checked, the
grid cell the object is in, and the 3 nearest other grid cells. The remaining
1596 grid cells and all the objects in them may be safely ignored.  For each
of those four grid cells, we know all the objects in them. A callback function
gets called passing the original object along with each object in any of those
four closest grid cells. This callback function can then do a finer collision
check.

<p>An example of this usage in snis_server.c, in torpedo_move():

<pre>
static void torpedo_move(struct snis_entity *o)
{
	if (o-&gt;alive)
		o-&gt;alive--;
	if (o-&gt;alive == 0) {
		delete_from_clients_and_server(o);
		return;
	}
	o-&gt;timestamp = universe_timestamp;
	set_object_location(o, o-&gt;x + o-&gt;vx, o-&gt;y + o-&gt;vy, o-&gt;z + o-&gt;vz);
	<b>space_partition_process(space_partition, o, o-&gt;x, o-&gt;z, o,
		torpedo_collision_detection);</b>
	if (!o-&gt;alive)
		delete_from_clients_and_server(o);
}
</pre>

For each object in the four grid cells nearest the torpedo, torpedo_collision_detection()
is called, where it does a more fine-grained test, e.g. calculating the distance between
the torpedo and the other object to see if it is below some minimum.

<pre>
static void torpedo_collision_detection(void *context, void *entity)
{
	struct snis_entity *t = entity;  /* target */
	struct snis_entity *o = context;

	[ ... complications omitted ... ]

	dist2 = object_dist2(t, o);

	[ ... ]

	if (t-&gt;type == OBJTYPE_PLANET &amp;&amp; dist2 &lt; t-&gt;tsd.planet.radius * t-&gt;tsd.planet.radius) {
		o-&gt;alive = 0; /* smashed into planet */
		schedule_callback2(event_callback, &amp;callback_schedule,
			"object-hit-event", (double) t-&gt;id,
			(double) o-&gt;tsd.torpedo.ship_id);

	[ ... ]
</pre>
Or, it might do a "moving-spheres" collision test:
<pre>
	double tolerance = 350.0;
	[ ... ]
	if (!projectile_collides(o-&gt;x, o-&gt;y, o-&gt;z, o-&gt;vx, o-&gt;vy, o-&gt;vz, 0.5 * tolerance,
				t-&gt;x, t-&gt;y, t-&gt;z, t-&gt;vx, t-&gt;vy, t-&gt;vz, 0.5 * tolerance, &amp;delta_t))
		return;
	o-&gt;alive = 0; /* hit!!!! */
	schedule_callback2(event_callback, &amp;callback_schedule,
					"object-hit-event", t-&gt;id, (double) o-&gt;tsd.torpedo.ship_i
</pre>

projectile_collides() in snis_server.c calls moving_spheres_intersection(), defined in quat.h:

<pre>
/* moving_spheres_intersection() returns true if moving spheres intersect, and fills
 * in *time at which intersection occurs if time_horizon &lt; 0 or
 * if *time &lt; time_horizon. IOW, negative time_horizon == no time horizon.
 * if *time &gt;= time_horizon &amp;&amp; time_horizon &gt;= 0 and there is an intersection,
 * then *time is filled in, otherwise, *time is not touched.
 */
int moving_spheres_intersection(union vec3 *s1, float r1, union vec3 *v1,
                                union vec3 *s2, float r2, union vec3 *v2,
                                float time_horizon, float *time);

</pre>

<p>There is one special type of object, the "block", (which may be a rectangular solid, a capsule,
or a sphere) for which special collision detection is done.  These objects are used by Lua scripts
to build composite objects, like the Demolisher spaceship in DEMOLISHER.LUA, or the big ship in
BIGSHIP.LUA. For these objects, we actually want to figure out the point on the surface of the object
with which we collide, not just a general proximity.

<p>For this, the shape_closest_point() function in shape_collision.c is used. This contains
sections of code to compute the closest point on the surface of a rectangular solid, a capsule
or a sphere.

<p>Additionally, we can find out where that point on the surface was on the previous tick of the
simulation with find_block_point_last_pos() in snis_server.c.  This is useful for rotating objects,
to figure out how fast and in what direction the point was moving when it hit us, which we can use
in a collision response. (See player_collision_detection() in snis_server.c)

<p>For collision response, see do_detailed_collision_impulse() in snis_server.c and elastic_collision()
in elastic_collision.h and elastic_collision.c

<h4><a name="snisserverplayershipmove">Player Ship movement</a></h4>

<p>The player's ship movement is done in snis_server.c in player_move(), called
from move_objects() via the "move" pointer:

<pre>
	go[i].move(&amp;go[i]);
</pre>

<p>Besides literally moving the player ship, many other things are done in player_move(),
essentially everything that happens on each tick of the simulation related to the player's
ship.

The actual movement part is done via a few function calls:

<pre>
	update_player_orientation(o);
	...
	update_player_position_and_velocity(o);
	...
        damp_yaw_velocity(&amp;o-&gt;tsd.ship.yaw_velocity, orientation_damping);
        damp_yaw_velocity(&amp;o-&gt;tsd.ship.pitch_velocity, orientation_damping);
        damp_yaw_velocity(&amp;o-&gt;tsd.ship.roll_velocity, orientation_damping);
	...
        /* Damp velocity */
        velocity_damping = player_velocity_damping +
                (1.0 - player_velocity_damping) * o-&gt;tsd.ship.nav_damping_suppression;

        if (fabs(o-&gt;tsd.ship.velocity) &lt; MIN_PLAYER_VELOCITY &amp;&amp;
                        o-&gt;tsd.ship.nav_damping_suppression &lt; 0.05)
                o-&gt;tsd.ship.velocity = 0.0;
        else
                o-&gt;tsd.ship.velocity *= velocity_damping;
</pre>

<p>update_player_orientation() implements both steering via the normal player's control inputs and
also automatic steering by "the computer" (e.g. standard orbit, or navigation commands issued to the
computer).  Normal player control inputs are handled at the end of this function:

<pre>
        /* Apply current rotational velocities... (player's input comes into play via this path) */
        quat_apply_relative_yaw_pitch_roll(&amp;o-&gt;orientation,
                        o-&gt;tsd.ship.yaw_velocity,
                        o-&gt;tsd.ship.pitch_velocity,
                        o-&gt;tsd.ship.roll_velocity);
</pre>

<p>quat_apply_relative_yaw_pitch_roll combines the specified yaw, pitch and roll velocity quaternions
(which are relative to an assumed body that is facing down the positive X axis with positive Y being up.)
into a single quaternion, and then this combined quaternion is transformed into the local orientation and
then applied to the local orientation.

<p>For "standard orbit", a desired location and orientation relative to the planet being orbited is
calculated, and then the ship's position and orientation are morphed towards this desired location and
orientation. To find this desired position and orientation, we find a vector P, from the center of the
planet to our ship, and make it a standard length some amount larger than the planet's radius.
Then project our ship's current velocity vector V to be parallel to the surface of the planet, and
then scale it to some constant fraction of planet radius (2.5 degrees, say).  Then add V to P to
produce D.  This is where we want to aim.  This gets us pointing in the right direction,
but we still need the right orientation.  We want our "up" vector to be perpendicular to our desired
velocity vector, but tangent to the planet's surface. The cross product of P and D gets us this desired
"up" direction.

<p>Computer steering, both for standard orbit, and for computer navigation (e.g. "Computer set a course
for the nearest asteroid."), is accomplished by adjusting o-&gt;tsd.ship.computer_desired_orientation and
o-&gt;tsd.ship.computer_steering_time_left.  As long as computer_steering_time_left is greater than zero,
then the ship's orientation is adjusted towards the computer_desired_orientation by applying available
maneuvering power. With each tick of the simulation, the computer_steering_time_left is decremented until
it reaches zero. So to initiate computerized steering towards a target, a desired orientation facing the
target is computed and stored in computer_desired_orientation, and computer_steering_time_left is set
to a value sufficiently high to allow the change in orientation to complete before it reaches zero,
typically COMPUTER_STEERING_TIME which as of this writing is 120, or 12 seconds.

<p>update_player_position_and_velocity() in snis_server.c actually moves the player in
a fairly straightforward way:

<pre>
        /* Apply player's thrust input from power model */
        do_thrust(o);

        /* Construct vector of desired velocity */
        desired_velocity.v.x = o-&gt;tsd.ship.velocity;
        desired_velocity.v.y = 0;
        desired_velocity.v.z = 0;
        quat_rot_vec_self(&amp;desired_velocity, &amp;o-&gt;orientation);

        /* Make actual velocity move towards desired velocity */
        o-&gt;vx = new_velocity(desired_velocity.v.x, o-&gt;vx);
        o-&gt;vy = new_velocity(desired_velocity.v.y, o-&gt;vy);
        o-&gt;vz = new_velocity(desired_velocity.v.z, o-&gt;vz);

        /* Move ship */
        set_object_location(o, o-&gt;x + o-&gt;vx, o-&gt;y + o-&gt;vy, o-&gt;z + o-&gt;vz);
</pre>

Collision detection for the player ship is done here as well:

<pre>
        space_partition_process(space_partition, o, o-&gt;x, o-&gt;z, o,
                                player_collision_detection);
</pre>

<p>See the section on <a href="#snisservercollision">collision detection</a>, above.

<h3><a name="snisservernpcship">NPC Ships</a></h3>
<h4><a name="snisservernpcmove">Movement</a></h4>

<p>NPC ship movement is done by ship_move() in snis_server.c, along with other
things about the NPC ships.

<p>NPC ships have a desired velocity towards which their actual velocity is moved.
update_ship_position_and_velocity() and update_ship_orientation() ar called to
update the NPC ship's position, velocity and orientation towards its desired
position and orientation.  The orientation is simply set to an orientation which
is facing in the direction of the current velocity. This area could definitely use
some improvement, as no consideration is given to choosing a reasonable "up" direction.

<h4><a name="snisservernpcai">NPC ship AI</a></h4>

<p>The ai_brain() function in snis_server.c is where all the NPC ship's desired
actions are computed. Each NPC ship has a small stack of union ai_data which
control what it does.  At any given moment, the top element of the NPC ship's ai
stack controls its actions. It may be attacking another ship, patroling a route,
being a cop, being a fleet member or fleet leader, idling, being a mining bot,
being a tow ship, and there are various RTS behaviors.  The ai_mode member of the
struct ai_stack_entry structure discriminates among the elements of the ai_data
union. There is a big switch statement in ai_brain() that calls an appropriate
function for each of the various ai_mode values.  Each of these functions typically
computes a desired velocity and orientation based on what they are trying to do.
For example, ai_attack_mode_brain() calculates a desired location based on the position
of the object being attacked, and adjusts a desired destination towards which
update_ship_position_and_velocity() will move.  Note: this particular case of AI_MODE_ATTACK
is not great, with specialized code in update_ship_position_and_velocity() and strange
usage of o-&gt;tsd.ship.dox, of o-&gt;tsd.ship.doy, and of o-&gt;tsd.ship.doz. This
area could be improved.  Most other ai functions rely on ai_ship_travel_towards() for
steering and navigation. ai_ship_travel_towards has some code to avoid crashing
into planets and to use the warp drive for longer transits.

<h4><a name="npcdebugging">Debugging NPC ship AI</a></h4>

<p>Debugging NPC ship AI is difficult.  Typically, you might spot an NPC ship exhibiting
some weird behavior, and the task is to figure out what it thinks it is doing, and why it
is misbehaving and how to make it behave more sensibly.  Since there
are a large number of NPC ships, simply adding print statements into the code is not very
helpful. I have found the following techniques to help.

<ol>
<li>When you spot some weird behavior, try to locate the NPC ship on the DEMON screen.
<li>Select the ship using the middle mouse button. From this you can obtain its ID.
For this example, let's suppose the ID is 100.
<li>Activate the console on the DEMON screen.
<li>Use the "follow 100" command on the DEMON screen to follow the ship visually.
(Use "follow" without specifying an ID to unfollow the ship when you're done).
<li>Turn off EXAG SCALE.
<li>Use the "aitrace 100" command on the DEMON screen to try to figure out what the NPC
ship thinks it's doing by observing what is printed on the console. ("aitrace" with no ID
will turn off AI tracing.)
<li>You can add calls to ai_trace() into the code if you need to.  You can also
modify the ai_trace() function in snis_server.c to log the ai_trace output to the
log file in case you need to record it for later analysis.
</ol>

Finding an NPC ship exhibiting the strange behavior can be a problem. Some
problems are "emergent", where at any given instant in time what the NPC ship
is doing might make some kind of sense, but the cumulative effect of what it
does over time may not make sense (e.g. circling around or doing a figure 8
around a waypoint.)

<h4><a name="snisservernpcfleet">NPC Fleets</a></h4>

<p>NPC ships may join or lead ad-hoc fleets. When an ship is is added into the
universe via add_ship() in snis_server.c, it's tsd.ship.nai_entries value (the
number of AI stack entries) is set to zero -- that is, it doesn't know what it's
doing. When the ship_move() function is called for this ship, it will call
ship_figure_out_what_to_do(), and at this point one of the things the ship might
do is become a fleet leader or join an existing fleet. At this point it will have
at the top of its AI stack AI_MODE_FLEET_LEADER or AI_MODE_FLEET_MEMBER. If it is
a fleet leader, it will move in the same manner as an individual ship that is patrolling.
If it is a fleet member, it will follow the fleet leader at a prescribed position in the
fleet according to the fleet shape (see fleet.c and fleet.h).

<h4><a name="snisserverhostile">Hostility matrix</a></h4>

<p>NPC ships belong to factions. Factions are defined in a configuration file and
read in via snis_read_factions().  See share/snis/factions.txt, and snis_faction.c and
snis_faction.h.  There is a "hostility matrix" which defines the hostility
level between each pair of factions. NPC ships compute a "danger vector" (see
compute_danger_vectors() in snis_server.c) which is a kind of vector sum taking
into account direction, distance and hostility of nearby ships, producing a vector
pointing in a "safer" direction. When the NPC ship calculates a high enough threat
level it will enter AI_MODE_FLEE, and beat a retreat in this "safer" direction.

<h3><a name="snisservertweak">Tweakable Variables</a></h3>

<p>There are many variables within snis_server (and also snis_client) which are
tweakable via the demon screen.  There is a framework for making variables tweakable
in snis_tweak.c and snis_tweak.h. There is a server_tweak[] variable that is an
array of struct tweakable_var_descriptor's. Each of these descriptors contains a
name, a description, a pointer to the variable, an indication of the variables type
(integer or float) and a minumum, maximum, and default value.  Similarly snis_client
has a client_tweak[] array. When a "set blah = value" command is typed on the client's
demon screen, first it scans the client_tweak[] array for a matching variable name,
and if found, sets the value if it is within the prescribed bounds (see set_clientside_variable()
in snis_client.c).  If it is not found, the command is forwarded to snis_server, where
the server_tweak[] variable is scanned for a match, and if found and the specified
value is within bounds, the variable is set (see server_builtin_set() in snis_server.c).

<h3><a name="snsiservernpccomms">NPC Comms (starbases, mining bot, etc)</a></h3>

<p>NPC comms is a bit complicated.  Each bridge has an npc_bot state associated with it
(npcbot in struct bridge_data in snis_server.c). The npc_bot state has an object_id
(e.g. for the starbase or mining bot that the bridge is communicating with), a channel,
a "parts_menu" integer, a struct npc_menu_item pointer, "current_menu", and an npc_special_bot_fn
special_bot.

<p>When you hail a starbase, your bridge's npc bot state object_id is set to the object
ID of the starbase, and the channel is switched to a random channel and the current_menu
pointer is set to starbase_main_menu, then generic_npc_bot() is called with an empty string
as input, which causes it to transmit the menu on the specified comms channel, which makes
it show up on the comms screen of the bridge. Subsequent comms transmissions from the
bridge are sent to this generic_npc_bot(), where they are interpreted as menu choices.
(see process_comms_transmission in snis_server.c, which calls send_to_npcbot(), which
will send the text either to generic_npc_bot, or to the npc bot state's special_bot, if
one has been assigned.  For simple menus, the generic_npc_bot will suffice, but for more
specialized communications, special bot functions are used and the special_bot function
pointer is used.

<p>The basic idea is the npc_bot_state is used for the NPC to remember its place in the
conversation between communications, and various specialized portions of the conversation
are handled by specialized functions and changing the special_bot pointer, while simple
menu trees can be handled by static menu structures and generic_npc_bot().

<p>TODO: describe this better.

<h3><a name="snisservernlproc">Natural Language Processing</a></h3>

<p>"Natural language processing" if it may be called that, is used to implement
the "ship's computer".  Commands may be typed in (preceded by "/computer ") on the
comms screen, or if using pocketsphinx, speech recognition may feed commands in via
a fifo. These commands are forwarded to snis_server. Commands come in via
process_instructions_from_client, either via OPCODE_COMMS_TRANSMISSION or via
OPCODE_NATURAL_LANGUAGE_REQUEST. For OPCODE_COMMS_TRANSMISSION, process_comms_transmission
is called, which then calls process_meta_comms_packet(), which then calls meta_comms_computer(),
which calls perform_natural_language_request(). OPCODE_NATURAL_LANGUAGE_REQUEST causes
process_natural_language_request to be called, which calls perform_natural_language_request().

<p>Perform_natural_language_request() calls snis_nl_parse_natural_language_request(), which
does the actual work of parsing the text and calling the appropriate functions via callbacks
set up earlier via init_natural_language_system() in snis_server.c. init_natural_language_system()
calls init_dictionary() which sets up the majority of the system's vocabulary and sets up all the
verb callbacks.

<p>See <a href="https://smcameron.github.io/space-nerds-in-space/snis-nl-slides/slideshow.html#1">this
set of slides about NLP in SNIS</a> for more information about how the parsing works. Use the arrow
keys to navigate the slides.  The slides probably don't work very well on mobile.  I also notice that
github's html preview seems to break the link, so here it is so you can copy/paste it:

<li>https://smcameron.github.io/space-nerds-in-space/snis-nl-slides/slideshow.html#1

<h3><a name="snisserverrtsmode">RTS mode</a></h3>

<p>TODO: this section

<h3><a name="snisserverdamconai">Damage Control Robot AI</a></h3>

<p>The damage control robot's AI is invoked by the damage control robot's move
function, damcon_robot_move(), which calls damcon_robot_think().  The robot has
a long term goal, and a short term goal. The short term goal generally involves
moving towards the next waypoint along the way to the long term goal.  The long
term goal involves figuring out the most critically damaged component in the system
or if already carrying it, getting to the repair station.  See find_robot_goal() in
snis_server.c. Then it computes a string of waypoints to that component by
the a_star algorithm, and these waypoints become short term goals.  The nodes searched
by the a_star algorithm are in a static array, damcon_waypoint_data[], defined in
snis_server.c which is worth a look if you want to understand how the robot works.

<h2><a name="snismultiverse">SNIS Multiverse</a></h2>

<p>The purpose of snis_multiverse is to make it possible for players to
traverse from one snis_server instance to another. For this to happen, the state of their
bridge which resides in one snis_server instance must somehow be transplanted into a different
snis_server instance. And it must work for multiple bridges.  All the snis_client instances
that make up a brdige must disconnect from one snis_server, and connect to another.

<p>The basic gist of it is that snis_server maintains a small database of bridge-states,
keyed by a hash of the ship name, password, and salt. Periodically, snis_server sends
the state of each connected bridge to snis_multiverse. When a new bridge is created within
snis_server, it may be a truly new ship, or it may be an existing ship.  If it is a truly new ship,
snis_multiverse will not know of it, and when snis_server informs snis_multiverse of this
new ship, snis_multiverse will create a new database entry for this new ship.  If it is an
existing ship, then it will have an existing state in the database, and snis_multiverse
will send this state to snis_server.

<h3><a name="mvdatastr">snis_multiverse data structures</a></h3>
<h4>struct starsystem_info</h4>
<pre>
static struct starsystem_info { /* one of these per connected snis_server */
	int socket;			/* socket to snis_server */
	int refcount;			/* reference count of threads accessing this star system */
	pthread_t read_thread;		/* thread to read from snis_server */
	pthread_t write_thread;		/* thread to write to snis_server */
	struct packed_buffer_queue write_queue; /* queue of data to be sent to snis server */
	pthread_mutex_t write_queue_mutex;	/* protects the queue */
	char starsystem_name[SSGL_LOCATIONSIZE]; /* corresponds to "location" parameter of snis_server */
	int bridge_count;		/* How many bridges are in this star system */
	int shutdown_countdown;		/* When this reaches zero (and some other conditions), shut down snis_server */
					/* see maybe_shutdown_snis_server() */
} starsystem[MAX_STARSYSTEMS] = { { 0 } };
static int nstarsystems = 0;
</pre>

<h4>struct bridge_info</h4>
<pre>
static struct bridge_info {
	unsigned char pwdhash[PWDHASHLEN];	/* hash of password, shipname, salt */
	int32_t initialized;			/* Have we unpacked data from snis server for this bridge? */
	struct snis_entity entity;		/* used to hold some of the bridge state */
	char starsystem_name[SSGL_LOCATIONSIZE];/* Current location of this bridge */
} ship[MAX_BRIDGES];
int nbridges = 0;
</pre>

<h3><a name="snismultiversethreads">snis_multiverse threads</a></h3>
<h4><a name="mvlistenerthr">snis_multiverse listener thread</a></h4>

<p>The listener thread handles incoming connection requests from snis_server instances.
It is started by start_listener_thread(), called by main(), and the thread function is
listener_thread_fn(), in snis_multiverse.c

<p>listener_thread_fn() enters a loop in which it accepts connections and for
each new connecting snis_server process calls service_connection(). service_connection()
verifies the protocol version via verify_client_protocol(), then reads the starsystem
name from the snis_server process, and records the starsystem in the starsystem[] array.
Then it creates a queue and a reader thread and a writer thread to communicate with this
snis_server process.

<h4><a name="mvreadwritethr">snis_multiverse reader/writer threads</a></h4>

<p>The reader thread is starsystem_read_thread() in snis_multiverse.c, and it
enters a loop which repeatedly calls process_instructions_from_snis_server();

<p>process_instructions_from_snis_server() reads a 1-byte opcode and then via
a switch statement, calls a function to process that opcode.

<p>The writer thread is starsystem_write_thread() in snis_multiverse.c, and it
enters a loop which repeatedly calls write_queued_updates_to_snis_server(),
and then sleeps for 5 seconds.

<p>write_queued_updates_to_snis_server() pulls items off the appropriate
snis_server queue and writes them through a socket to the remote snis_server
process, or if the queue is empty, fabricates a NO-OP instruction and writes
that through the socket to the remote snis_server process.

<p>Instructions enter the queue to be written to snis_server via other threads.

<h4><a name="mvssglthr">SSGL thread</a></h4>

<p>A thread to periodically update ssgl_server with snis_multiverse's information
is created by ssgl_register_gameserver(), called from main() in snis_multiverse.c

<h4><a name="mvmainthr">snis_multiverse Main thread</a></h4>

<p>The main thread of snis_multiverse begins in main() in snis_multiverse.c.
It constructs the starmap[] array by scanning ./share/snis/solarsystems
for assets.txt files to obtain the coordinates of each star system and construct
an adjacency list in starmap_adjacency[].  This is used to know what the valid
paths are between starsystems.

<p>The listener thread is started, it registers with ssgl_server, and then it enters
a loop in which it "wrangles" snis_server processes and checkpoints data (saves
brige information into a file).

<p>wrangle_snis_server_processes() first makes a list of starsystems containing
at least one active bridge (that is to say, a list of snis_servers with at least one
connected snis_client). It then makes a list of active starsystems or starsystems
which are adjacent to active starsystems.

<p>Then, for each possible star system, if that star system is active, or adjacent
to an active star system, a snis_server instance is started if it isn't already running,
or if that star system is not active, and is not adjacent to an active starsystem,
then if a snis_server instance is running for that star system and sufficient time has
passed with it remaining inactive, that snis_server instance is shut down.

<p>In this way, if players are in any given star system, any star system they can
reach in a single hop will have a running snis_server instance in which they may
land.

<p>For checkpointing data, checkpoint_data() is called from main() in multiverse.c.
checkpoint_data() loops through the ship[] array, saving the bridge info for each
ship. The data is saved in the snis_db directory.

<h3><a name="mvdataxfer">Data Transfer between snis_multiverse and snis_server<a></h3>

<p>In the snis_server's server_tracker thread, it will connect to the snis_multiverse
process which it locates by querying ssgl_server, and write the starsystem name to
snis_multiverse.

<p>When a new snis_client connects to snis_server, it provides a shipname and password
to snis_server (see add_new_player() in snis_server.c).

<p>In move_objects() in snis_server(), for each player ship (each bridge, essentially),
update_multiverse() is called periodically (every 10 seconds).

<p>update_multiverse() does one of several things. If this bridge is not yet verified
and verification has not yet been requested, update_multiverse requests verification of
the bridge (sends SNISMV_OPCODE_VERIFY_CREATE or SNISMV_OPCODE_VERIFY_EXISTS to snis_multiverse(),
depending on whether the player intended to create a new ship, or join an existing ship).
Along with these opcodes a password hash is supplied.

<p>If verification has already been requested, but not yet received, update_multiverse()
does nothing.

<p>If the ship is already verified by snis_multiverse, then a large buffer containing the
entire ship's state is constructed via build_bridge_update_packet() (see snis_bridge_update_packet.h
and snis_bridge_update_packet.c), and sent to snis_multiverse using SNISMV_OPCODE_UPDATE_BRIDGE.

<p>When snis_multiverse receives SNISMV_OPCODE_VERIFY_CREATE, (the player is requesting
to create a new ship) it calls verify_existence() with 0 for the 2nd parameter,
should_already_exist. It then looks up the password hash to see if it already exists.
If it does, then snis_multiverse sends SNISMV_VERIFICATION_RESPONSE_FAIL to snis_server
along with the password hash.  If the entry does not yet exist, snis_multiverse sends
SNISMV_VERIFICATION_RESPONSE_PASS along with the password has to snis_server.

<p>When snis_multiverse receives SNISMV_OPCODE_VERIFY_EXISTS, (the player is requesting
to join an existing ship), it calls verify_existence with 1 for the 2nd parameter,
should_already_exist. It then looks up the password hash to see if it already exists.
If it does not exist, then snis_multiverse sends SNISMV_VERIFICATION_RESPONSE_FAIL
along with the password hash to snis_server. If the ship does exist, then
snis_multiverse sends SNISMV_VERIFICATION_RESPONSE_PASS along with the
password hash to snis_server. It then also calls send_bridge_update_to_snis_server(),
which calls build_bridge_update_packet() in snis_bridge_update_packet.c to build a
large packet containing the entire bridge state and sends it to snis_server using opcode
SNISMV_OPCODE_UPDATE_BRIDGE.

<p>When snis_multiverse receives SNISMV_OPCODE_UPDATE_BRIDGE, it calls update_bridge()
in snis_multiverse.c and it reads the bridge state and unpacks it into a struct snis_entity with
unpack_bridge_update_packet() (see snis_bridge_update_packet.c) and update's the bridge's
current starsystem (it may have gone through a warp gate to a different star system). This
data will later be written out to a file via checkpoint_data() in the main thread.

<p>When snis_server receives SNISMV_OPCODE_UPDATE_BRIDGE, it calls process_update_bridge() in
snis_server.c which saves the bridge's x, y, and z and reads in the packed bridge data and
unpacks it into the struct snis_entity for that bridge, then restores the bridge's x, y, and
z position. In this way the save state from snis_multiverse is transferred into the state
within snis_server.

<h2><a name="ssglserver">SSGL Server</a></h2>
<h3><a name="ssgloverview">SSGL Overview</a></h3>
<p>SSGL ostensibly stands for "super simple game lobby", whether it's all that simple
is another question. It provides a means for different processes within Space Nerds in
Space to find one another. Although SSGL predates any knowledge I had of Google's BNS
(Borg Name Service), I later came to realize it performs much the same function, though
it's less well thought out and less robust.
(See <a href="https://ai.google/research/pubs/pub43438">https://ai.google/research/pubs/pub43438</a>)

<p>ssgl_server has no real UI to speak of, it is purely a network process. (snis_client
does provide a UI to present to the user snis_server instances which it has discovered
via ssgl_server).

<p>There is a single process, ssgl_server, which implements the lobby.  It broadcasts
packets on the local network advertising its presence, which allows clients to find
it without knowing where it is.  It uses port 2914 (udp and tcp).

<p>"Game servers" periodically connect to ssgl_server and transmit identifying information
(e.g what amounts to a service name, IP address, and port) ssgl_server will drop any
entries which haven't been heard from recently enough on the assumption that they are dead.

<p>"Game clients" (which may also be "game servers") connect to the lobby to find
"game servers" that they want to connect to.

<p>In the case of Space Nerds in Space, snis_client is a "game client", but not a
"game server", and uses ssgl_server to locate snis_server instances.  snis_client
also listens for the broadcast packets to help locating the ssgl_server. snis_server is
both a "game client" and a "game server", registering itself with ssgl_server
so that other programs may find it, and using ssgl_server to find snis_multiverse.
snis_multiverse is also a "game server" and a "game client", registering with ssgl_server
as a server so that snis_servers may find it, and using ssgl_server to know what
snis_server instances exist so that it may maintain an internal list of active snis_server
instances for "autowrangling" (automatically starting and stopping) them.

<h3><a name="ssgldatastruct">SSGL Main data structures</a></h3>

<p>From ssgl/ssgl.h:
<pre>
struct ssgl_game_server {
        uint32_t ipaddr;
        uint16_t port;
        char game_type[15];             /* What kind of game is this? */
        char game_instance[20];         /* which instance on the server of the game */
        char server_nickname[15];       /* server nickname where game is hosted */
        char protocol_version[9];
        char location[SSGL_LOCATIONSIZE];
        uint32_t nconnections;
};
</pre>

<p>This structure is used to define a "game server", and is transmitted to ssgl_server
by game servers, and from ssgl_server to game_clients, as well as stored internally
by ssgl_server.

<p>The ipaddr and port are the IP address and port number of a game server (IPV4 only, obviously).
How the game_type, game_instance, server_nickname, protocol_version, and location are used is pretty much
up to the design of whatever games are registering (though only SNIS uses ssgl at this time, or
probably ever), although ssgl_server does provide a way for game clients to filter servers based
on game_type.

<p>nconnections is supposed to be the number of clients currently connected to a game server, so that
a user of a lobby could have any idea of how many users were in any given game server, though it is
provided by the game servers and forwarded by ssgl_server without caring about the value, so it could
be used for whatever any game system wanted to use it for.

<p>All integer quantites are transmitted in network byte order (big endian).

<p>ssgl_server maintains an array of struct ssgl_game_server called game_server[].

From ssgl/ssgl.h:
<pre>
struct ssgl_lobby_descriptor {
        uint32_t ipaddr;
        uint16_t port;
        char hostname[32];
};
</pre>

<p>The struct ssgl_lobby_descriptor is broadcast as a UDP packet periodically to advertise the
IP addr, port and (non-canonical) hostname of the ssgl_server.

From ssgl/ssgl.h
<pre>
struct ssgl_client_filter {
        char game_type[15];
};
</pre>
struct ssgl_client_filter allows game_clients to filter game_servers returned to it by ssgl_server
by game type. The idea was that ssgl_server could potentially be a lobby to any sort of game, but
in general, any one game client would only be interested in game servers for a particular type
of game, but not in all game servers <em>regardless</em> of type of game.


<h3><a name="ssglserverthr">SSGL server threads</a></h3>

<h4>SSGL server main thread</h4>

<p>The main thread of ssgl_server (main(), ssgl_server.c) listens on a thread for
incoming connections and calls service() (ssgl_server.c) for each connection. service()
creates a service_thread() thread to service the connection.

<h4>SSGL server "service" thread</h4>

<p>One of these threads is created for each connection. The client identifies itself to ssgl_server
as a game client or a game server (for the purposes of this particular connection), and for game
servers, service_game_server() is called, for game clients, service_game_client() is called.

<p>service_game_server() reads a struct ssgl_game_server from the connection and stores
or updates an entry in the game_server[] array, and marks it with a timestamp, and returns,
at which point the connection is terminated.

<p>service_game_client() reads a struct ssgl_client_filter from the connection and constructs
a list of struct ssgl_game_server entries that match the filter.  If the filter is "*", then
the client will get all ssgl_game_server entries that ssgl_server knows about, otherwise only
entries with a matching game type.

<p>ssgl_server then writes the number of matching entries (in network byte order) into the
connection, followed by the struct ssgl_game_server entries. It then returns and closes the
connection.

<p>You will notice that game servers and clients do not maintain a long lived connection to
the ssgl_server, but periodically establish new, short lived connections.

<h4>ssgl_server game server expiration thread</h4>

<p>start_game_server_expiration_thread() is called from main() which starts a thread function
expire_game_servers().  expire_game_servers() (ssgl/ssgl_server.c) loops, waking up once per minute, and deletes
any entries in the game_server[] array that have not been updated within the last 20 seconds.

<h4>ssgl_server broadcast lobby info thread</h4>

<p>start_broadcast_lobby_info_thread() is called from main() and starts a thread function
broadcast_lobby_info().  broadcast_lobby_info() (ssgl/ssgl_server.c) enters a loop in which
it periodically (every 2 seconds) broadcasts UDP packet containing a struct
ssgl_lobby_descriptor advertising the IP address and tcp port of itself (ssgl_server) so
that clients may more easily find it.

<p>
<h2><a name="buildsystem">Build System</a></h2>

<h3><a name="dependencies">Prerequisites (dependencies)</a></h3>
<p>You can find a list of prerequistes and build instructions here:
<a href="https://smcameron.github.io/space-nerds-in-space/#buildinstructions">https://smcameron.github.io/space-nerds-in-space/#buildinstructions</a>
<h2><a name="utilities">Utilities</a></h2>

<h2><a name="assets">Assets</a></h2>

<p>Art assets are partially in git, in share/snis, and partially on spacenerdsinspace.com.
You can download the additional assets via "make update-assets", or if you just want to see
what <em>would</em> be downloaded without actually downloading it, "make check-assets".

<p>TODO: fill in this section about how assets are managed, how to create assets, etc.

<h2><a name="fileindex">Source File Index</a></h2>
<p align=center><table width=80%, border=1>
<tr><td>arbitrary_spin.c, arbitrary_spin.h</td><td>Functions for computing predictable deterministic pseudorandom spins and orientations</td></tr>
<tr><td>arraysize.h</td><td>Macro for computing the size of arrays</td></tr>
<tr><td>a_star.c, a_star.h</td><td>A* pathfinding algorithm</td></tr>
<tr><td>a_star_test.c</td><td>Test program for A* pathfinding algorithm</td></tr>
<tr><td>bline.c, bline.h</td><td>Bresenham's line drawing algorithm with callback interface</td></tr>
<tr><td>build_bug_on.h</td><td>Macro to enforce various assertions at compile time</td></tr>
<tr><td>build_info.h</td><td>Automatically generated file containing hashes of source code</td></tr>
<tr><td>check-endianness.c</td><td>Program to check endianess of build host used by gather_build_info script</td></tr>
<tr><td>c-is-the-locale.c</td><td>Module to override set_locale() to enforce that the locale is "C".</td></tr>
<tr><td>commodities.c, commodities.h</td><td>Functions to read and add to the list of commodities (things that can be cargo
bought and sold at starbases) that the game knows about</td></tr>
<tr><td>compat.h</td><td>Some (very few) things that differ from one OS to another</td></tr>
<tr><td>container-of.h</td><td>Macro for obtaining the address of a structure given the address of a known member of that structure</td></tr>
<tr><td>corporations.c, corporations.h</td><td>List of fictional corporations known to the game</td></tr>
<tr><td>crater.c, crater.h</td><td>Functions to procedurally generate crater heightmaps, used by earthlike.</td></tr>
<tr><td>damcon-robot-points.h</td><td>Point data used to draw damage control robot.</td></tr>
<tr><td>device-io-sample-1.c</td><td>Example program for interfacing the game to custom control hardware.</td></tr>
<tr><td>docking_port.c, docking_port.h</td><td>Structures and a function for reading docking port information defining positions
and orientations of docking ports on various starbase models</td></tr>
<tr><td>earthlike.c</td><td>Program to procedurally generate cubemap textures for earthlike and rocky planets</td></tr>
<tr><td>elastic_collision.c, elastic_collision.h</td><td>Function which given positions, masses, and velocities of
two colliding bodies, computes new positions and velocities of those objects assuming an elastic collision.</td></tr>
<tr><td>entity.c, entity.h</td><td>Defines device independent data structures and functions related to renderable entities. This is a core part
of the renderer</td></tr>
<tr><td>entity_private.h</td><td>Defines a portion of renderer entity data structures that are private to the renderer and need not be known by
code that is using the renderer</td></tr>
<tr><td>fleet.c, fleet.h</td><td>Defines data structures and functions related to grouping NPC ships into fleets</td></tr>
<tr><td>generate_skybox.c</td><td>Program to procedurally generate skybox cubemap textures</td></tr>
<tr><td>graph_dev_gdk.c</td><td>Obsolete. This was a GDK implementation of the interface defined by
graph_dev.h. This was a core part of the
software renderer used by the limited client. (The limited client ceased to exist when snis_client
was converted from GTK to SDL2.)</td></tr>
<tr><td>graph_dev.h</td><td>Interface of device dependent portion of the renderer (graph_dev_gdk and graph_dev_opengl implement this interface)</td></tr>
<tr><td>graph_dev_mesh_stub.c, graph_dev_mesh_stub.h</td><td>Stub routines used by snis_server to satisfy requirements of mesh.c.  mesh.c calls some
functions to initialize some things related to rendering, but since snis_server doesn't render, it doesn't need these things.  So for snis_server,
they are stubbed out.</td></tr>
<tr><td>graph_dev_opengl.c</td><td>OpenGL implementation of the interface defined by graph_dev.h, this is a core part of the renderer.</td></tr>
<tr><td>infinite-taunt.c, infinite-taunt.h</td><td>Procedurally generates various bits of text (planet descriptions, NPC ship communications, ship names,
planet names, etc.)</td></tr>
<tr><td>joystick.c, joystick.h</td><td>Code to deal with joystick hardware, allows polling joysticks for state.</td></tr>
<tr><td>joystick_config.c, joystick_config.h</td><td>Code for reading joystick config file and mapping joystick events to game controls</td></tr>
<tr><td>key_value_parser.c, key_value_parser.h</td><td>Code for parsing text files of key value pairs into a predefined data structure</td></tr>
<tr><td>liang-barsky.c, liang-barsky.h</td><td>Implementation of Liang-Barsky line clipping algorithm for clipping lines to a viewport</td></tr>
<tr><td>material.c, material.h</td><td>Defines structures and functions to initialize those structures for communicating various material
attributes to OpenGL shaders (unfortunately, it's not PBR though)</td></tr>
<tr><td>mathutils.c, mathutils.h</td><td>Various math utility functions</td></tr>
<tr><td>matrix.c, matrix.h</td><td>Various matrix functions</td></tr>
<tr><td>mesh.c, mesh.h</td><td>Various 3D mesh related functions. Defines struct mesh, and functions to fabricate various
meshes, and miscellaneous mesh related functions</td></tr>
<tr><td>mesh_viewer.c</td><td>Program to view models with the same renderer the game uses.</td></tr>
<tr><td>mikktspace/mikktspace.c, mikktspace.h</td><td>God-like code from Morten Mikkelsen to compute vertex tangent
and bitangent vectors given a mesh with vertex normals and a uv mapping. Useful (required) for normal mapping.</td></tr>
<tr><td>mtwist.c, mtwist.h</td><td>Mersenne Twister pseudorandom number generator implementation</td></tr>
<tr><td>my_point.c, my_point.h</td><td>Defines a 2D point structure and some operations on it. Used for drawing some 2D shapes (e.g. the damage control robot,
and some other things on the damage control screen)</td></tr>
<tr><td>names.c, names.h</td><td>Code to procedurally generate names</td></tr>
<tr><td>nebula_noise.c</td><td>(Unfinished) program to procedurally generate nebulas</td></tr>

<tr><td>nonuniform_random_sampler.c, nonuniform_random_sampler.h</td><td>Code
to define distributions of discrete items and relative probabilites and to
sample (choose an item) from those distributions. For example, you could define
a distribution with two items, a copper penny, and a solid gold coin with the
former being 100 times more likely than the latter, and then sample from that
distribution and get (approximately) 100 pennies for every gold coin.</td></tr>

<tr><td>ogg_to_pcm.c, ogg_to_pcm.h</td><td>Functions to decode ogg-vorbis audio files</td></tr>
<tr><td>opengl_cap.c, opengl_cap.h</td><td>Functions to query OpenGL about capabilities</td></tr>
<tr><td>open-simplex-noise.c, open-simplex-noise.h</td><td>C implementation of Kurt Spencer's Open Simplex Noise</td></tr>
<tr><td>oriented_bounding_box.c, oriented_bounding_box.h</td><td>Defines data structure for an oriented bounding box and a function to
return the closest point on the surface of that box to a given point. Useful for collision detection.</td></tr>
<tr><td>placeholder-part-points.h</td><td>2D drawing data for "parts" on the damage control screen</td></tr>
<tr><td>placeholder-socket-points.h</td><td>2D drawing data for "sockets" on the damage control screen</td></tr>
<tr><td>placeholder-system-points.h</td><td>2D drawing data for "systems" on the damage control screen</td></tr>
<tr><td>planetary_atmosphere.c, planetary_atmosphere.h</td><td>Code for procedurally generating chemical compositions of planetary atmospheres</td></tr>
<tr><td>png_utils.c, png_utils.h</td><td>Code for reading and writing PNG images</td></tr>
<tr><td>power-model.c, power-model.h</td><td>Code to model the players' ship's systems as an electrical circuit</td></tr>
<tr><td>print_ship_attributes.c</td><td>Program to print out ship attribute names and offsets (for debugging purposes).</td></tr>
<tr><td>pronunciation.c, pronunciation.h</td><td>Code to fix up abbreviations like SB-00 and WG-01 to "starbase zero" and "warp gate one" so that
text-to-speech systems can pronounce them reasonably.</td></tr>
<tr><td>pthread_util.c, pthread.h</td><td>Utility function for creating threads and setting some attributes on them (e.g.
thread name and whether they are detached or not).</td></tr>
<tr><td>quat.c, quat.h</td><td>Utility code for vec2, vec3, and quaternion structures and for performing various mathematical
operations on these structures.</td></tr>
<tr><td>replacement_assets.c, replacement_assets.h</td><td>Code to allow replacing asset files at runtime with other, different asset files.
This exists mainly to allow old assets in git to remain there, undisturbed, while still using newer different assets not in git.</td></tr>
<tr><td>rootcheck.c, rootcheck.h</td><td>Code to check if we are running as root.  Nobody should be running the game as root.</td></tr>
<tr><td>rts_unit_data.c, rts_unit_data.c</td><td>Code and data about units in the (unfinished) real time strategy game mode.</td></tr>
<tr><td>shader.c, shader.h</td><td>Code to read, construct and compile OpenGL shaders from files.</td></tr>
<tr><td>shape_collision.c, shape_collision.h</td><td>Code to perform closest point operation on cuboids, spheres,
and capsules. Useful for collision detection.</td></tr>
<tr><td>shield_strength.c, shield_strength.h</td><td>Code to probe a shield at a given wavelength for strength</td></tr>
<tr><td>ship_registration.c, ship_registration.h</td><td>Implements a ship registry for NPC ships, allowing bounties to be set upon them.</td></tr>
<tr><td>snis_alloc.c, snis_alloc.h</td><td>Implements an allocation pool from which objects of a constant size may be allocated an de-allocated.</td></tr>
<tr><td>snis_asset_dir.c, snis_asset_dir.h</td><td>Common code used to allow overriding of the asset directory used by SNIS programs.</td></tr>
<tr><td>snis_bin_dir.c, snis_bin_dir.h</td><td>Common code used to find the binary directory used by SNIS programs</td></tr>
<tr><td>snis_bridge_update_packet.c, snis_bridge_update_packet.h</td><td>Defines the packet used to transfer bridge state between snis_server and snis_multiverse</td></tr>
<tr><td>snis_button.c, snis_button.h</td><td>Code for button UI widget</td></tr>
<tr><td>snis_cardinal_colors.h</td><td>Constants for some cardinal colors</td></tr>
<tr><td>snis_client.c</td><td>The snis_client program.</td></tr>
<tr><td>snis-culture.h</td><td>Defines the possible economy, government and tech-level descriptions for planets.</td></tr>
<tr><td>snis_damcon_systems.c, snis_damcon_systems.h</td><td>Defines various attributes of things on the damage control screen</td></tr>
<tr><td>snis_debug.c, snis_debug.h</td><td>Debug code to dump out various attributes of various things in the game on the demon console.</td></tr>
<tr><td>snis-device-io.c, snis-device-io.h</td><td>Code to read in opcodes from a unix domain socket on the client intended to be used
to support custom built hardware controls. Nothing actually uses this interface that I am aware of.</td></tr>
<tr><td>snis_dmx.c, snis_dmx.h</td><td>Untested DMX lighting implementation. Needs work to integrate with the rest of the game.</td></tr>
<tr><td>snis_entity_key_value_specification.h</td><td>A key-value specification for struct snis_entity defining a text name, type,
and offset for fields within struct snis_entity. Used by snis_server to implement the Lua function to get ship attributes,
and by snis_multiverse for saving and reading bridge state files.</td></tr>
<tr><td>snis_event_callback.c, snis_event_callback.h</td><td>Allows callbacks to be created, scheduled and called. This is ultimately how Lua
callbacks for events are implemented.</td></tr>
<tr><td>snis_faction.c, snis_faction.h</td><td>Defines faction reading code, and code to extract faction attributes and hostility factors between factions.</td></tr>
<tr><td>snis_fixup_gnome_key_screwups.h</td><td>Redefine some old GDK key names</td></tr>
<tr><td>snis_font.c, snis_font.h</td><td>Defines line segments making up a font, and functions to operate on fonts</td></tr>
<tr><td>snis_font_orig.c</td><td>Unused</td></tr>
<tr><td>snis_gauge.c, snis_gauge.h</td><td>Gauge UI widget</td></tr>
<tr><td>snis_graph.c, snis_graph.h</td><td>Defines many OpenGL drawing and graphics functions</td></tr>
<tr><td>snis.h</td><td>Defines many types and constants, most notably struct snis_entity</td></tr>
<tr><td>snis_hash.c, snis_hash.h</td><td>Defines hash functions used for passwords</td></tr>
<tr><td>snis_keyboard.c, snis_keyboard.h</td><td>Defines key mapping and functions to read key mapping config file</td></tr>
<tr><td>snis_label.c, snis_label.h</td><td>Label UI widget</td></tr>
<tr><td>snis_limited_graph.c</td><td>Obsolete. Defines many GDK drawing and graphics functions once used
by the limited client (which doesn't exist since the conversion from GTK to SDL2.)</td></tr>
<tr><td>snis_log.h</td><td>Defines some snis log file functions (in terms of ssgl log file functions) Not very heavily used.</td></tr>
<tr><td>snis_marshal.c, snis_marshal.h</td><td>Defines a packed buffer structure and functions for packing
or unpacking various data types into or out of such buffers</td></tr>
<tr><td>snis_multiverse.c</td><td>snis_multiverse program</td></tr>
<tr><td>snis_multiverse.h</td><td>Defines opcodes for communicating between snis_multiverse and snis_server.</td></tr>
<tr><td>snis_nl.c, snis_nl.h</td><td>Zork-like natural language parser used to implement "the ship's computer"</td></tr>
<tr><td>snis_opcode_def.c, snis_opcode_def.h</td><td>Defines the "syntax" of opcodes so that snis_client and snis_server may
to some degree ensure that they are compatible with one another at run time. Helps detect version mismatches.</td></tr>
<tr><td>snis_packet.h</td><td>Defines opcodes.  Note, many structs are defined in here that are not actually used
anymore due to snis_marshal.c containing printf() like functions to pack buffers.  However it may be that the size
of these structures is still relevant (e.g. sizeof(struct blah) maybe used as an allocation size, even though the
struct blah itself is not used. Some care must be taken when modifying opcode protocols.</td></tr>
<tr><td>snis_preferences.c, snis_preferences.h</td><td>Code to save and restore prior choices made on the network
setup screen so the user doesn't have to repeatedly enter the same data over and over.</td></tr>
<tr><td>snis_pull_down_menu.c, snis_pull_down_menu.h</td><td>Pull down menu UI widget</td></tr>
<tr><td>snis_server.c</td><td>The snis_server program.</td></tr>
<tr><td>snis_server_tracker.c, snis_server_tracker.h</td><td>Code to track presense of snis_server and snis_multiverse instances (by querying ssgl_server). This
is used to maintain the state of the star map in snis_client, among other things.</td></tr>
<tr><td>snis_ship_type.c, snis_ship_type.h</td><td>Code to read struct ship_type_entry data from a config file file</td></tr>
<tr><td>snis_sliders.c, snis_sliders.h</td><td>Slider UI widget</td></tr>
<tr><td>snis_socket_io.c, snis_socket_io.h</td><td>Code to read/write from sockets, handling errors</td></tr>
<tr><td>snis_strip_chart.c, snis_strip_chart.h</td><td>Strip chart UI widget (e.g. for network stats, EMF graph on comms station)</td></tr>
<tr><td>snis_test_audio.c</td><td>A program for debugging audio problems.</td></tr>
<tr><td>snis_text_input.c, snis_text_input.h</td><td>Text input UI widget</td></tr>
<tr><td>snis_text_window.c, snis_text_window.h</td><td>Text window UI widget</td></tr>
<tr><td>snis_tweak.c, snis_tweak.h</td><td>Framework for allowing variables to be tweakable via the demon screen</td></tr>
<tr><td>snis_typeface.c, snis_typeface.h</td><td>Various sizes of fonts</td></tr>
<tr><td>snis_ui_element.c, snis_ui_element.h</td><td>Code for generically handling a variety of widgets, or lists of widgets,
and associating widgets with display modes</td></tr>
<tr><td>snis_version.h</td><td>#defines SNIS_VERSION</td></tr>
<tr><td>solarsystem_config.c, solarsystem_config.h</td><td>Code for allocating, reading, and freeing solarsystem assets</td></tr>
<tr><td>sounds.h</td><td>Defines constants for predefined sound effects</td></tr>
<tr><td>space-part.c, space-part.h</td><td>space partitioning algorithm used for collision detection</td></tr>
<tr><td>spelled_numbers.c, spelled_numbers.h</td><td>Code to convered spelled out numbers like "one hundred fifty" to numeric values, e.g. 150.
This is used to process text coming from speech recognition systems (e.g. pocketsphinx).</td></tr>
<tr><td>ssgl/ssgl_connect_to_lobby.c, ssgl_connect_to_lobby.h</td><td>Contains functions for game servers and clients to connect to the lobby</td></tr>
<tr><td>ssgl/ssgl_gameclient_example.c</td><td>Example ssgl lobby gameclient client.</td></tr>
<tr><td>ssgl/ssgl_gameserver_example.c</td><td>Example ssgl lobby gameserver client.</td></tr>
<tr><td>ssgl/ssgl_get_gamelobby_port.c, ssgl_get_gameloby_port.h</td><td>Returns the game lobby port number</td></tr>
<tr><td>ssgl/ssgl_get_primary_host_ip_addr.c</td><td>Returns the IP address of the current host (one that can route to 8.8.8.8)</td></tr>
<tr><td>ssgl/ssgl.h</td><td>Main header file for ssgl</td></tr>
<tr><td>ssgl/ssgl_log.c, ssgl_log.h</td><td>Logging functions for ssgl</td></tr>
<tr><td>ssgl/ssgl_protocol_id.h</td><td>Some #defines for the ssgl protocol to prevent version mismatches</td></tr>
<tr><td>ssgl/ssgl_recv_game_servers.c</td><td>Function to return a list of game servers from a lobby</td></tr>
<tr><td>ssgl/ssgl_register_for_bcast_packet.c</td><td>Function to start a thread and register a callback to receive broadcast packets containing lobby server IP addrs and ports</td></tr>
<tr><td>ssgl/ssgl_register_gameserver.c</td><td>Functions to register a game server with the lobby</td></tr>
<tr><td>ssgl/ssgl_sanitize.c, ssgl_sanitize.h</td><td>Functions to sanitize data from ssgl clients</td></tr>
<tr><td>ssgl/ssgl_server.c</td><td>The main ssgl_server program.</td></tr>
<tr><td>ssgl/ssgl_sleep.c</td><td>Threadsafe sleep function</td></tr>
<tr><td>ssgl/ssgl_socket_io.c, ssgl_socket_io.h</td><td>Code to read/write to sockets with error handling</td></tr>
<tr><td>stacktrace.c, stacktrace.h</td><td>Code to obtain a stacktrace at the current execution point (for debugging).</td></tr>
<tr><td>starbase-comms.c, starbase-comms.h</td><td>Procedurally generates starbase communications about attacks</td></tr>
<tr><td>starbase_metadata.c, starbae_metadata.h</td><td>Code to related starbase snis_entities to starbase model files and docking port files</td></tr>
<tr><td>starmap_adjacency.c, starmap_adjacency.h</td><td>Constructs and adjacency graph for starsystems based on proximity</td></tr>
<tr><td>stl_parser.c, stl_parser.h</td><td>Code to read STL files, Wavefront OBJ files, and Oolite .dat files</td></tr>
<tr><td>string-utils.c, string-utils.h</td><td>Various string utility functions</td></tr>
<tr><td>termios2.h</td><td>termios2.h file from linux kernel.  This should be included by termios.h, but it is not always present.</td></tr>
<tr><td>test_crater.c</td><td>Test program for crater.c code</td></tr>
<tr><td>test-mtwist.c</td><td>Test program for mtwist.c code</td></tr>
<tr><td>test_mtwist_float.c</td><td>Test program for mtwist.c code</td></tr>
<tr><td>test-obj-parser.c</td><td>Test program for stl_parser.c code</td></tr>
<tr><td>test-quat.c</td><td>Test program for quat.c code</td></tr>
<tr><td>test_snis_dmx.c</td><td>Test program for snis_dmx.c code</td></tr>
<tr><td>test_solarsystem_config.c</td><td>Test program for solarsystem_config.c code</td></tr>
<tr><td>thrust_attachment.c, thrust_attachement.h</td><td>Code for reading thrust attachment data files (defining where thrusters are on models).</td></tr>
<tr><td>triangle.h</td><td>Defines struct triangle</td></tr>
<tr><td>turret_aimer.c, turret_aimer.h</td><td>Code to automatically aim and move a 3D turret</td></tr>
<tr><td>ui_colors.c, ui_colors.h</td><td>Code to allow customization of UI colors</td></tr>
<tr><td>util/cloud-mask-normalmap.c</td><td>Utility program to mask normalmaps with cloud maps</td></tr>
<tr><td>util/generate_solarsystem_positions.c</td><td>Code to generate solarsystem positions such that a reasonable proximity based adjacency map will be produced.</td></tr>
<tr><td>util/mask_clouds.c</td><td>Code create a cloud mask to composite clouds onto terrain textures for earthlike planets</td></tr>
<tr><td>util/sample_image_colors.c</td><td>This program samples 4 points on an image, averages them and prints out the RGB value.
The intended use is to sample the textures for gas giants to produce a reasonable
color for the atmosphere effect.</td></tr>
<tr><td>vec4.c, vec4.h</td><td>Defines union vec4 and some operations on them</td></tr>
<tr><td>vertex.h</td><td>Defines struct vertex</td></tr>
<tr><td>workqueue.c, workqueue.h</td><td>Generic work queue and thread pool implementation. Used mainly
for decoding PNG files outside the main rendering thread.</td></tr>
<tr><td>wwviaudio.c, wwviaudio.h</td><td>The main audio library used to mix and playback many concurrent audio streams, based on portaudio</td></tr>
</table>
</body>
